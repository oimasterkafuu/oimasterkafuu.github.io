<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oimaster.top</id>
    <title>oimaster</title>
    <updated>2023-07-10T14:24:54.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oimaster.top"/>
    <link rel="self" href="https://oimaster.top/atom.xml"/>
    <subtitle>これこそが人間の感情の極み。希望よりも熱く、絶望よりも深いモノーー愛、よ</subtitle>
    <logo>https://oimaster.top/images/avatar.png</logo>
    <icon>https://oimaster.top/favicon.ico</icon>
    <rights>All rights reserved 2023, oimaster</rights>
    <entry>
        <title type="html"><![CDATA[当你看到一道题……]]></title>
        <id>https://oimaster.top/post/VDodg3tO5/</id>
        <link href="https://oimaster.top/post/VDodg3tO5/">
        </link>
        <updated>2023-07-10T16:20:12.000Z</updated>
        <summary type="html"><![CDATA[<p>当你看到了一道时限 <code>1000ms</code> 的题🤔……</p>
]]></summary>
        <content type="html"><![CDATA[<p>当你看到了一道时限 <code>1000ms</code> 的题🤔……</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://oimaster.top/post-images/1688998599259.png" alt="" loading="lazy"></figure>
<p>不错，我要做这道题！💪 本地测试一下！</p>
<figure data-type="image" tabindex="2"><img src="https://oimaster.top/post-images/1688998612326.png" alt="" loading="lazy"></figure>
<p>时间就差一点！差一点，交交看！🤞</p>
<figure data-type="image" tabindex="3"><img src="https://oimaster.top/post-images/1688998626729.png" alt="" loading="lazy"></figure>
<p>这怎么全挂了啊……不可能！😱</p>
<p>时限 <code>1000ms</code> 改成 <code>2000ms</code>，看你过不过。🤔</p>
<figure data-type="image" tabindex="4"><img src="https://oimaster.top/post-images/1688998638760.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://oimaster.top/post-images/1688998644474.png" alt="" loading="lazy"></figure>
<p>过了，赶紧改回来！😅</p>
<figure data-type="image" tabindex="6"><img src="https://oimaster.top/post-images/1688998747076.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://oimaster.top/post-images/1688998599259.png" alt="" loading="lazy"></figure>
<p>改回来了，这样又不会有人过了！</p>
<p>好耶！🎉</p>
<p><s>肯定不是我的代码问题！</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打算写假期日报！]]></title>
        <id>https://oimaster.top/post/gb9I1Pn8V/</id>
        <link href="https://oimaster.top/post/gb9I1Pn8V/">
        </link>
        <updated>2023-07-05T00:06:43.000Z</updated>
        <summary type="html"><![CDATA[<p>开创一个日报，想通过这种方式督促自己干点正事。这个假期无特殊情况每天都写。有特殊情况将会在下一次写的时候说明。</p>
]]></summary>
        <content type="html"><![CDATA[<p>开创一个日报，想通过这种方式督促自己干点正事。这个假期无特殊情况每天都写。有特殊情况将会在下一次写的时候说明。</p>
<!-- more -->
<p>每一个日报会包括以下的内容。</p>
<ul>
<li>干什么系列
<ul>
<li>今天要干什么</li>
<li>今天干了什么</li>
<li>今天没干什么</li>
<li>明天要干什么</li>
</ul>
</li>
<li>情绪系列
<ul>
<li>今天心情怎么样</li>
<li>今天为什么这样</li>
</ul>
</li>
<li>其他</li>
</ul>
<p>特殊地，如果当日发布了其他文章，日报可以不写。</p>
<p>希望大家督促我完成这个任务。对于所有的日报，请从 <a href="/tag/rPyI6irTc/" class="post-tags">#日报</a> 标签或顶栏进入，不显示在主页列表中或归档页面。</p>
<p><strong>如果您觉得我做得不好，请从日报页面底部的评论区炸我一下。</strong></p>
<p>日报从 2023-07-05 开始写。日报在列表中显示时右侧没有配图。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用计算机解决 15 数码问题]]></title>
        <id>https://oimaster.top/post/-jrYcZ0cc/</id>
        <link href="https://oimaster.top/post/-jrYcZ0cc/">
        </link>
        <updated>2023-07-01T07:35:24.000Z</updated>
        <summary type="html"><![CDATA[<p>期末考试阶段，有不少压力。这时候，看到了一个小玩具。</p>
]]></summary>
        <content type="html"><![CDATA[<p>期末考试阶段，有不少压力。这时候，看到了一个小玩具。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://oimaster.top/post-images/1688193736552.jpeg" alt="" loading="lazy"></figure>
<p>我认为这有助于我放松。于是，我尝试解决它。然而，这花了我 5 分钟左右。</p>
<p>我感到很不服气。我打算征服它。</p>
<h2 id="宽广度优先搜索">宽（广）度优先搜索</h2>
<p>我打算使用电脑提升解题速度。刚开始，我认为这不难，应该在二十几步内完成。</p>
<p>此时，使用深度优先搜索显然不适合，因为在一步错误下很可能分叉出很多种可能。于是我打算用宽搜。</p>
<p>因为才完成一个 Vue 项目，所以我顺手写了一点 JS 代码（现在被我删了，很可惜你们看不到）。当我按下回车后，我的 Node.js 瞬间卡死了。</p>
<p>我以为可能是 Javascript 执行速度太慢，就重写了一份 C++ 代码。仍然很慢。已经到了深夜，我便回去复习了。</p>
<h2 id="a">A*</h2>
<p>这事情本来结束了的，然而我在晚上玩耍时看到了一个网站。</p>
<iframe src="https://dpxx.github.io/" width="100%" height="750"></iframe>
<p>它提供的样例是 <code>5,1,4,7,2,11,3,8,9,6,14,15,13,10,0,12</code>，一共有 19 步，但是它瞬间就解决了。</p>
<p>我查看了它的源代码。它使用了启发式搜索。我不能落后。</p>
<p>因为 C++ 里面提供了 priority_queue，再加上 Javascript 在复杂计算时太慢了，所以我优先使用 C++。</p>
<p>思路是这样的：</p>
<ul>
<li>对于每一个节点，遍历所有的数码；</li>
<li>对于每一个数码，计算数码应该在的位置；</li>
<li>接下来，计算当前位置与正确位置的距离，并累加。</li>
</ul>
<p>这样，得到了节点的分数。据此进行 A*。</p>
<p>另外，因为使用一整个数组搜索太不方便，我使用了 <code>getHash()</code> 函数进行哈希。实际上，由于我用的是 <code>unsigned long long</code> 类型，所以不需要取模，也不会有重复的数值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;

#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

bool isValid(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    // verify size
    if (puzzle.size() != 4)
        return false;
    for (int i = 0; i &lt; 4; i++) {
        if (puzzle[i].size() != 4)
            return false;
    }

    bool exist[16] = { false };
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            if (puzzle[i][j] &lt; 0 || puzzle[i][j] &gt; 15)
                return false;
            if (exist[puzzle[i][j]])
                return false;
            exist[puzzle[i][j]] = true;
        }
    }

    return true;
}

unsigned long long getHash(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    unsigned long long hash = 0;
    for (int i = 0; i &lt; 16; i++) {
        hash = hash * 16 + puzzle[i / 4][i % 4];
    }
    return hash;
}

int getScore(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    int score = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            if (puzzle[i][j] == 0)
                continue;
            score += abs(i - (puzzle[i][j] - 1) / 4) + abs(j - (puzzle[i][j] - 1) % 4);
        }
    }
    return score;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; puzzle(4, vector&lt;int&gt;(4));

    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j];
    }

    int time = clock();

    if (!isValid(puzzle)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl;
        return 0;
    }

    // A* search
    priority_queue&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;, vector&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;,
                   greater&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt;
        pq;
    set&lt;unsigned long long&gt; visited;
    pq.push(make_pair(getScore(puzzle), puzzle));
    visited.insert(getHash(puzzle));

    map&lt;unsigned long long, unsigned long long&gt; parent;
    map&lt;unsigned long long, char&gt; direction;
    map&lt;unsigned long long, int&gt; depth;
    map&lt;unsigned long long, int&gt; cost;

    while (!pq.empty()) {
        vector&lt;vector&lt;int&gt;&gt; cur = pq.top().second;
        pq.pop();

        if (getScore(cur) == 0) {
            // print solution
            vector&lt;unsigned long long&gt; path;
            unsigned long long curHash = getHash(cur);
            while (curHash != getHash(puzzle)) {
                path.push_back(curHash);
                curHash = parent[curHash];
            }
            reverse(path.begin(), path.end());

            cout &lt;&lt; &quot;Solution:&quot; &lt;&lt; endl;
            for (int i = 0; i &lt; path.size(); i++) {
                cout &lt;&lt; direction[path[i]];
                if (i % 5 == 4)
                    cout &lt;&lt; ' ';
            }
            cout &lt;&lt; endl;

            cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1.0 / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
            return 0;
        }

        int curDepth = depth[getHash(cur)];
        int curCost = cost[getHash(cur)];

        int zeroX = -1, zeroY = -1;
        for (int i = 0; i &lt; 4; i++) {
            for (int j = 0; j &lt; 4; j++) {
                if (cur[i][j] == 0) {
                    zeroX = i;
                    zeroY = j;
                    break;
                }
            }
        }

        // move up
        if (zeroX &gt; 0) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX - 1][zeroY]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'U';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move down
        if (zeroX &lt; 3) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX + 1][zeroY]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'D';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move left
        if (zeroY &gt; 0) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX][zeroY - 1]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'L';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move right
        if (zeroY &lt; 3) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX][zeroY + 1]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'R';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }
    }

    cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>运行起来大概是这样的<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<pre><code class="language-bash">oimaster@kafuu 23-07-01 16:02:33 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b   
oimaster@kafuu 23-07-01 16:02:45 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
9 5 1 4
3 7 2 8
6 0 10 11
13 14 15 12
Solution:
ULURR DLDLU URRDL DRRD
Time: 1.758ms
</code></pre>
<p>然后我就发了条空间。</p>
<figure data-type="image" tabindex="2"><img src="https://oimaster.top/post-images/1688195588821.png" alt="" loading="lazy"></figure>
<h2 id="快一点的-a">快一点的 A*</h2>
<p>当我发出去后，我意识到自己的行为十分愚蠢。A* 算法很多人都会。然而，因为我使用了大量的 STL，但是编译时连 <code>-O2</code> 都没有加上，所以很容易被超越。</p>
<p>吓得我赶紧加上了 <code>-Ofast</code>。可以发现确实快了不少。</p>
<pre><code class="language-sh">oimaster@kafuu 23-07-01 16:24:10 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b       
oimaster@kafuu 23-07-01 16:24:16 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
3 5 7 4
6 9 2 12
0 13 11 14
10 1 8 15
Solution:
DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD
Time: 1438.26ms
oimaster@kafuu 23-07-01 16:24:19 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b -Ofast
oimaster@kafuu 23-07-01 16:24:29 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
3 5 7 4
6 9 2 12
0 13 11 14
10 1 8 15
Solution:
DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD
Time: 265.271ms
oimaster@kafuu 23-07-01 16:24:32 ~/Documents/code/puzzle &gt;&gt;&gt; 
</code></pre>
<p>立刻发了条空间刷新我的记录。两条空间间隔不到十分钟。显然是加了点编译优化选项，改不了多少代码。</p>
<figure data-type="image" tabindex="3"><img src="https://oimaster.top/post-images/1688196144848.png" alt="" loading="lazy"></figure>
<h2 id="位运算版-a">位运算版 A*</h2>
<p>如上面所说，第二天下午，我就去写了位运算。这个比较麻烦。首先，让我们思考如何表示一个棋盘。</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _
</code></pre>
<p>将所有的空格换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么可以发现所有的数字都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>16</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left[0, 16\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 中的整数，很方便位运算。</p>
<p>按照从上到下，从左到右的顺序，就可以把上面的棋盘转换成十六进制：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mo fence="true">(</mo><mn>123456789</mn><mi>a</mi><mi>b</mi><mi>c</mi><mi>d</mi><mi>e</mi><mi>f</mi><mn>0</mn><mo fence="true">)</mo></mrow><mn>16</mn></msub><mo>=</mo><msub><mrow><mo fence="true">(</mo><mn>1311768467463790320</mn><mo fence="true">)</mo></mrow><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">\left(123456789abcdef0\right)_{16} = \left(1311768467463790320\right)_{10}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span><span class="mord">8</span><span class="mord">9</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">6</span><span class="mord">3</span><span class="mord">7</span><span class="mord">9</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，每一个数位代表着一个位置上的数字。</p>
<p>对于这个大数字，我们思考如何存储它。<code>unsigned long long</code> 可以吗？它的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0, 2^{64}-1\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span>，也就是一直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18446744073709551615</mn></mrow><annotation encoding="application/x-tex">18446744073709551615</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mord">7</span><span class="mord">3</span><span class="mord">7</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord">5</span><span class="mord">1</span><span class="mord">6</span><span class="mord">1</span><span class="mord">5</span></span></span></span>。远远大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1311768467463790320</mn></mrow><annotation encoding="application/x-tex">1311768467463790320</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">6</span><span class="mord">3</span><span class="mord">7</span><span class="mord">9</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span></span></span></span>，放心吧。</p>
<p>所以就可以写出输入：</p>
<pre><code class="language-cpp">#define puzzle unsigned long long

puzzle p = 0;
for (int i = 0; i &lt; 16; i++) {
    int x;
    cin &gt;&gt; x;
    p = (p &lt;&lt; 4) + x;
}
</code></pre>
<p>接下来，就是处理移动。这将会是一个大工程。首先，让我们找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 所在的数位。</p>
<pre><code class="language-cpp">int zero = 0;
while (((x &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++;
</code></pre>
<p>如果我们要向上方移动，横着看，我们就需要向前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个数位。例如，我们要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上移：</p>
<pre><code>123456789abcdef0
               ^
123456789ab0defc
           ^
</code></pre>
<p>其本质是：</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _

1 2 3 4
5 6 7 8
9 10 11 _
13 14 15 12
</code></pre>
<p>于是，你就可以写出代码，获取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上方的数字是多少：</p>
<pre><code class="language-cpp">int top = zero + 4;
int dig = (x &gt;&gt; (top &lt;&lt; 2)) &amp; 15;
</code></pre>
<p>奇怪，第一行为什么是 <code>zero + 4</code> 而不是 <code>zero - 4</code> 呢？不知道你们有没有发现，我们的数位是<strong>颠倒</strong>的。所以正确的移动其实是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 位到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 位。：</p>
<pre><code>123456789abcdef0
               ^
               0

123456789ab0defc
           ^
           4
</code></pre>
<p>不过到目前为止，我们只是获取到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mo>←</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">dig \leftarrow 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>。我们还需要把这个数字移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 原来所在的位置。</p>
<pre><code class="language-cpp">x |= (unsigned long long)dig &lt;&lt; (zero &lt;&lt; 2);
</code></pre>
<p>这行代码使用「或」运算，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的二进制全部为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，所以或运算本质上就是拷贝。</p>
<p>于此同时，我们还需要把原来上方的格子清零。我们需要「与」运算。运算时，我们需要保证上方的格子对应「0」从而删除，而其他的位置不变。于是自然又会想到将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mo fence="true">(</mo><mn>15</mn><mo fence="true">)</mo></mrow><mn>10</mn></msub><mo>=</mo><msub><mrow><mo fence="true">(</mo><mn>1111</mn><mo fence="true">)</mo></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\left(15\right)_{10} = \left(1111\right)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span></span></span></span> 移动到那一位，同时取反，让其他位变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>——不干扰。</p>
<p>于是写出：</p>
<pre><code class="language-cpp">x &amp;= ~((unsigned long long)15 &lt;&lt; (top &lt;&lt; 2));
</code></pre>
<p>整理一下上方所有的位运算，压到一行里：</p>
<pre><code class="language-cpp">x = (x | ((x &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2)) &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2));
</code></pre>
<p>搞定！其他方向同理，于是我们就可以写出搜索时的代码。</p>
<h3 id="判断无解">判断无解</h3>
<p>为了方便我的时间测量，防止没必要的浪费，我有必要写出来判断无解的代码。</p>
<p>让我们观察一下有解的几种情况。</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _

1 2 3 4
5 6 7 8
9 10 11 12
13 14 _ 15

1 2 3 4
5 6 7 8
9 10 11 _
13 14 15 12
</code></pre>
<p>为了方便处理，我们可以把二维转为一维，和之前一样，从上到下，从左到右。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>0</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>从数列中删去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，得到了：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>你会发现，第一行和第二行没有变化。第三行相对两者来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 移动到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[13, 14, 15\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span> 的后方，创造了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个逆序对。</p>
<p>让我们再把空格往上移动一下。</p>
<pre><code>1 2 3 4
5 6 7 _
9 10 11 8
13 14 15 12
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 8, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 向后移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 格，创造了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个逆序对，此时共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 个逆序对。</p>
<p>仔细观察，会发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的坐标与逆序对的奇偶性有关系。每当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 向上移动奇数行（所在坐标也为奇数行），逆序对的数量为奇数。反之，在偶数行时，逆序对的数量为偶数。</p>
<p>对于左右移动，不影响序列，所以我们不必考虑。</p>
<p>和位运算周旋半个小时就可以写出下面的代码：</p>
<pre><code class="language-cpp">bool hasSolution(puzzle p) {
    int cnt = 0, zeroX = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0) {
            zeroX = i &gt;&gt; 2;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15;
            if (y == 0)
                continue;
            if (y &lt; x)
                cnt++;
        }
    }
    return ((cnt + zeroX) &amp; 1) == 0;
}
</code></pre>
<p>最后写完整代码时发现之前的 <code>cost</code> 没有任何作用，就删掉了。另外，为了加快速度，我改成了 <code>unordered_map</code> 和 <code>unordered_set</code>。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

using namespace std;

#define puzzle unsigned long long

inline bool isValid(puzzle p) {
    unsigned exist = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = p &amp; 15;
        if (x &lt; 0 || x &gt; 15)
            return false;
        if (exist &amp; (1llu &lt;&lt; x))
            return false;
        exist |= (1llu &lt;&lt; x);
        p &gt;&gt;= 4;
    }
    return true;
}

unsigned getScore(puzzle p) {
    unsigned score = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0)
            continue;
        score += abs((i &gt;&gt; 2) - ((x - 1) &gt;&gt; 2)) + abs((i &amp; 3) - ((x - 1) &amp; 3));
    }
    return score;
}

bool hasSolution(puzzle p) {
    int cnt = 0, zeroX = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0) {
            zeroX = i &gt;&gt; 2;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15;
            if (y == 0)
                continue;
            if (y &lt; x)
                cnt++;
        }
    }
    return ((cnt + zeroX) &amp; 1) == 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    puzzle p = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x;
        cin &gt;&gt; x;
        p = (p &lt;&lt; 4) + x;
    }

    int time = clock();

    if (!isValid(p)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl
             &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
        return 0;
    }

    if (!hasSolution(p)) {
        cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl
             &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
        return 0;
    }

    priority_queue&lt;pair&lt;unsigned, puzzle&gt;, vector&lt;pair&lt;unsigned, puzzle&gt;&gt;, greater&lt;pair&lt;unsigned, puzzle&gt;&gt;&gt;
        pq;
    unordered_map&lt;puzzle, puzzle&gt; parent;
    unordered_map&lt;puzzle, char&gt; direction;
    unordered_map&lt;puzzle, unsigned&gt; depth;

    pq.push(make_pair(0, p));
    depth[p] = 1;

    while (!pq.empty()) {
        puzzle curr = pq.top().second;
        pq.pop();

        if (curr == 0x123456789abcdef0llu) {
            stack&lt;char&gt; path;
            while (curr != p) {
                path.push(direction[curr]);
                curr = parent[curr];
            }

            cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; path.size() &lt;&lt; &quot; steps):&quot; &lt;&lt; endl;
            int cnt = 0;
            while (!path.empty()) {
                cout &lt;&lt; path.top() &lt;&lt; (((++cnt) % 5 == 0) ? &quot; &quot; : &quot;&quot;);
                path.pop();
            }
            cout &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
            return 0;
        }

        unsigned currDepth = depth[curr];

        int zero = 0;
        while (((curr &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++;

        if (zero &lt; 12) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'D';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if (zero &gt; 3) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 4) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero - 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'U';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if ((zero &amp; 3) != 3) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 1) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero + 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'R';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if ((zero &amp; 3) != 0) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 1) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero - 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'L';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }
    }

    cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><s>我又提供了一份提高组的阅读程序代码。考察重点：位运算；难度★★★★★。</s></p>
<p>它运行起来，更快了。看到它运行起来，我更快乐。你无法想象这东西我调试了多久。</p>
<figure data-type="image" tabindex="4"><img src="https://oimaster.top/post-images/1688199346710.png" alt="" loading="lazy"></figure>
<p>位运算确实提升了不少。</p>
<h2 id="更快的方法">更快的方法</h2>
<p>至此，搜索我们基本到头了。但是在一些复杂的题目上，仍然要花几分钟才能算出。</p>
<p>我们是想要什么？是要最优解吗？那么搜索当然可以。</p>
<p>但我的目标不是这个。我的目标是在做任何题目的时候都快速解决，但是步数没有太大要求。</p>
<p>wikiHow，该你出场了：<a href="https://www.wikihow.com/Solve-a-15-Puzzle">https://www.wikihow.com/Solve-a-15-Puzzle</a></p>
<p><strong>请读者先自行阅读上方文章。</strong></p>
<p>一切都很轻松，除了几个问题，需要我们细化。</p>
<ol>
<li>人类很容易移动，那么计算机怎么办？如何从机械的角度看待「移动」的过程？</li>
<li>文中 3.2 说：「Place 9 on the right side of 13.  Move 13 temporarily if you have to.」<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>什么时候叫做「if you have to.」？我又该如何移动？</li>
<li>最后一步「If they don't go to their original places, do method 3 again by mixing only the last two rows.」<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>有何意义？</li>
</ol>
<p>然后，我们来进行解决。</p>
<h3 id="问题-1">问题 1</h3>
<p>将一个数码往上移，本质上是将空格移动到其上方，然后再将空格移动到原数码的位置。这是因为每次移动空格本质上是与相邻的数码交换位置。</p>
<h3 id="问题-2">问题 2</h3>
<p>通过玩实体的 15 数码，我发现有 2 种情况需要移动「13」。分别是（<code>?</code> 代表任意数字，包括空格；<code>_</code> 代表空格，此时 <code>?</code> 不包括空格）：</p>
<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
9 ? ? ?
</code></pre>
<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
_ 9 ? ?
</code></pre>
<p>这两种情况很容易互相转换。可以这样：</p>
<ol>
<li>将右侧 6 个 <code>?</code> 中的空格移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的右侧，得到：<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
9 _ ? ?
</code></pre>
</li>
<li>移动「9」。</li>
</ol>
<p>此时，因为每当尝试将「9」改变位置时必将堵死，所以需要「13」移动。移动的方法，我总结出来以下的结果：</p>
<ol>
<li>允许改动「13」的位置，将「9」移动到第三行、第三列（即原来「11」所在的位置）。</li>
<li>在将「9」保持不动的情况下，利用左下角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的空间将「13」归回原位。</li>
<li>移动「9」到第三行，第二列，完成此步骤。</li>
</ol>
<p>因为第三行、第三列并不在左下角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的空间内，所以现在移动「13」的时候必将不会干扰「9」。</p>
<h3 id="问题-3">问题 3</h3>
<p>一句话：实践表明，<strong>没必要</strong>。</p>
<h3 id="代码实现">代码实现</h3>
<p>首先，我对于每一个格子都给予编号。</p>
<pre><code>0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
</code></pre>
<p>接下来，我对于当前重要的格子和已经解决的格子，赋予 <code>blocked</code> 属性。</p>
<p>在 <code>vector&lt;int&gt; findPath(int from, int to);</code> 中，程序会通过宽度优先搜索，给出一条 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo>→</mo><mi>t</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">from \rightarrow to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span></span></span></span> 的路径，不经过 <code>blocked</code> 指定的格子。</p>
<p>在 <code>vector&lt;int&gt; move(Puzzle puzzle, int from, int to);</code> 中，程序会多次调用 <code>findpath()</code>，将在 <code>from</code> 位置上的<strong>数码</strong>移动到 <code>to</code>，即包括了空格子的计算。</p>
<p>在 <code>bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to);</code> 中，程序会记录答案，并返回是否成功。</p>
<p>更多的内容，请参照注释。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
using namespace std;

typedef vector&lt;vector&lt;int&gt;&gt; Puzzle;
#define cell2num(x, y) ((x)*4 + (y))

// check if the puzzle is valid
bool isValid(Puzzle puzzle) {
    vector&lt;bool&gt; exist(16, false);
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] &lt; 0 || puzzle[i / 4][i % 4] &gt; 15)
            return false;
        if (exist[puzzle[i / 4][i % 4]])
            return false;
        exist[puzzle[i / 4][i % 4]] = true;
    }
    return true;
}

// get if the puzzle has solution
bool hasSolution(Puzzle puzzle) {
    int inversions = 0;
    int zeroRow = 0;
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] == 0) {
            zeroRow = i / 4;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            if (puzzle[j / 4][j % 4] == 0)
                continue;
            if (puzzle[j / 4][j % 4] &gt; puzzle[i / 4][i % 4])
                inversions++;
        }
    }
    return (inversions + zeroRow) % 2 == 1;
    // the index starts from 0, so the result of inversions should be ~~even~~ -&gt; odd
}

vector&lt;vector&lt;bool&gt;&gt; blocked(4, vector&lt;bool&gt;(4, false));
// the cells that have been already solved will be blocked

const string arrows[4] = { &quot;↑&quot;, &quot;↓&quot;, &quot;←&quot;, &quot;→&quot; };
const int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
// opposite to the arrows, because when we play the game, we don't move the empty cell, but move the numbers
// but in the code, we move the empty cell, so the direction is opposite to the arrows

// get the position of the number
int getPos(Puzzle puzzle, int num) {
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] == num)
            return i;
    }
    return -1;
}

// find the path from the start to the end, do not need the puzzle itself, but 'blocked' is needed
vector&lt;int&gt; findPath(int from, int to) {
    queue&lt;int&gt; q;

    vector&lt;int&gt; parent(16, -1);
    // the parent of the cell, -1 means not visited, -2 means the start cell

    q.push(from);
    parent[from] = -2;

    // using BFS to find the path, can be replaced by A*
    // but it's not necessary since the puzzle is small
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        if (cur == to)
            break;
        int x = cur / 4, y = cur % 4;
        for (int i = 0; i &lt; 4; i++) {
            int nx = x + dir[i][0], ny = y + dir[i][1];
            if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4)
                continue;
            if (blocked[nx][ny])
                continue;
            int next = cell2num(nx, ny);
            if (parent[next] != -1)
                continue;
            parent[next] = cur;
            q.push(next);
        }
    }

    if (parent[to] == -1)
        return vector&lt;int&gt;();

    // get the path

    stack&lt;int&gt; transit;
    while (to != -2) {
        transit.push(to);
        to = parent[to];
    }

    // get the direction of the path
    vector&lt;int&gt; path;
    while (transit.size() &gt; 1) {
        int from = transit.top();
        transit.pop();
        int to = transit.top();

        int xFrom = from / 4, yFrom = from % 4;
        int xTo = to / 4, yTo = to % 4;

        for (int i = 0; i &lt; 4; i++) {
            if (xFrom + dir[i][0] == xTo &amp;&amp; yFrom + dir[i][1] == yTo) {
                path.push_back(i);
                break;
            }
        }
    }
    return path;
}

vector&lt;int&gt; move(Puzzle puzzle, int from, int to) {
    // find a whole path from the start to the end
    vector&lt;int&gt; path = findPath(from, to);
    if (path.empty())
        return vector&lt;int&gt;();

    vector&lt;int&gt; moves;
    // the moves that need to be done, including the empty cell
    int currX = from / 4, currY = from % 4;
    for (int i = 0; i &lt; path.size(); i++) {
        int nextX = currX + dir[path[i]][0], nextY = currY + dir[path[i]][1];
        int zeroPos = getPos(puzzle, 0);
        int zeroX = zeroPos / 4, zeroY = zeroPos % 4;

        if (zeroPos != cell2num(nextX, nextY)) {
            // the empty cell is not next to the number, so the move is not valid
            // move the empty cell to the position next to the number

            // block the current cell
            blocked[currX][currY] = true;

            // find the path from the empty cell to the position next to the number
            vector&lt;int&gt; path2 = findPath(zeroPos, cell2num(nextX, nextY));
            if (path2.empty())
                return vector&lt;int&gt;();

            // move the empty cell
            for (int j = 0; j &lt; path2.size(); j++) {
                int nextZeroX = zeroX + dir[path2[j]][0], nextZeroY = zeroY + dir[path2[j]][1];
                moves.push_back(path2[j]);
                swap(puzzle[zeroX][zeroY], puzzle[nextZeroX][nextZeroY]);
                zeroX = nextZeroX, zeroY = nextZeroY;
            }

            // unblock the current cell
            blocked[currX][currY] = false;
        }

        // moves.push_back(path[i]); this is the move of the number, not the empty cell
        // move push_back opposite (0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2)
        moves.push_back(path[i] ^ 1);

        swap(puzzle[currX][currY], puzzle[nextX][nextY]);
        currX = nextX, currY = nextY;
    }

    return moves;
}

bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to) {
    // do not need to move
    if (from == to)
        return true;

    vector&lt;int&gt; moves = move(puzzle, from, to);
    if (moves.empty())
        return false;

    for (int i = 0; i &lt; moves.size(); i++) {
        ans.push_back(moves[i]);
        int zeroPos = getPos(puzzle, 0);
        int zeroX = zeroPos / 4, zeroY = zeroPos % 4;
        swap(puzzle[zeroX][zeroY], puzzle[zeroX + dir[moves[i]][0]][zeroY + dir[moves[i]][1]]);
    }

    return true;
}

int main() {
    Puzzle puzzle(4, vector&lt;int&gt;(4));
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j];
    }

    if (!isValid(puzzle)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl;
        return 0;
    }
    if (!hasSolution(puzzle)) {
        cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl;
        return 0;
    }

    vector&lt;int&gt; ans;
    bool flag = true;

    // step 1: move [1] to pos 0
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 1), 0);
    blocked[0][0] = true;

    // step 2: move [2] to pos 1
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 2), 1);
    blocked[0][1] = true;

    // step 3: move [4] to pos 2
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2);

    // step 4: if [3] is in pos 3 or (7 &amp;&amp; 3 is empty), we have to move it away
    //         -&gt; move [3] to pos 10

    if (getPos(puzzle, 3) == 3 || (getPos(puzzle, 3) == 7 &amp;&amp; getPos(puzzle, 0) == 3)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 10);
        blocked[2][2] = true;
        // move [4] back to pos 2, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2);
        blocked[2][2] = false;
    }
    blocked[0][2] = true;

    // step 5: move [3] to pos 6
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 6);
    blocked[1][2] = true;

    // step 6: move [4] to pos 3
    blocked[0][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 3);
    blocked[0][3] = true;

    // step 7: move [3] to pos 2
    blocked[1][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 2);
    blocked[0][2] = true;

    // now we have [1] [2] [3] [4] in the right place, and they are blocked

    // step 8: move [5] to pos 4
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 5), 4);
    blocked[1][0] = true;

    // step 9: move [6] to pos 5
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 6), 5);
    blocked[1][1] = true;

    // step 10: move [8] to pos 6
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6);

    // step 11: if [7] is in pos 7 or (11 &amp;&amp; 7 is empty), we have to move it away
    //          -&gt; move [7] to pos 14

    if (getPos(puzzle, 7) == 7 || (getPos(puzzle, 7) == 11 &amp;&amp; getPos(puzzle, 0) == 7)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 14);
        blocked[3][2] = true;
        // move [8] back to pos 6, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6);
        blocked[3][2] = false;
    }
    blocked[1][2] = true;

    // step 12: move [7] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 10);
    blocked[2][2] = true;

    // step 13: move [8] to pos 7
    blocked[1][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 7);
    blocked[1][3] = true;

    // step 14: move [7] to pos 6
    blocked[2][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 6);
    blocked[1][2] = true;

    // now we have [5] [6] [7] [8] in the right place, and they are blocked

    // step 15: move [13] to pos 8
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8);

    // step 16: if 9 is in pos 12 or (13 &amp;&amp; 12 is empty), we have to move it away
    //          -&gt; move [9] to pos 10

    if (getPos(puzzle, 9) == 12 || (getPos(puzzle, 9) == 13 &amp;&amp; getPos(puzzle, 0) == 12)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 10);
        blocked[2][2] = true;
        // move [13] back to pos 8, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8);
        blocked[2][2] = false;
    }
    blocked[2][0] = true;

    // step 17: move [9] to pos 9
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 9);
    blocked[2][1] = true;

    // step 18: move [13] to pos 12
    blocked[2][0] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 12);
    blocked[3][0] = true;

    // step 19: move [9] to pos 8
    blocked[2][1] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 8);
    blocked[2][0] = true;

    // now we have [9] [13] in the right place, and they are blocked

    // step 20: move [14] to pos 9
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9);

    // step 21: if [10] is in pos 13 or (14 &amp;&amp; 13 is empty), we have to move it away
    //          -&gt; move [10] to pos 11

    if (getPos(puzzle, 10) == 13 || (getPos(puzzle, 10) == 14 &amp;&amp; getPos(puzzle, 0) == 13)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 11);
        blocked[2][3] = true;
        // move [14] back to pos 9, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9);
        blocked[2][3] = false;
    }
    blocked[2][1] = true;

    // step 22: move [10] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 10);
    blocked[2][2] = true;

    // step 23: move [14] to pos 13
    blocked[2][1] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 13);
    blocked[3][1] = true;

    // step 24: move [10] to pos 9
    blocked[2][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 9);
    blocked[2][1] = true;

    // now we have [10] [14] in the right place, and they are blocked

    // step 25: move [11] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 11), 10);
    blocked[2][2] = true;

    // step 26: move [12] to pos 11
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 12), 11);
    blocked[2][3] = true;

    // step 27: move [15] to pos 14
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 15), 14);
    blocked[3][2] = true;

    // now we have [11] [12] [15] in the right place, and they are blocked

    if (!flag) {
        cout &lt;&lt; &quot;Something went wrong&quot; &lt;&lt; endl;
        return 0;
    }

    // make the answer simpler, removing unnecessary moves
    for (int i = 0; i &lt; ans.size(); i++) {
        if ((ans[i] ^ ans[i + 1]) == 1) {
            ans.erase(ans.begin() + i);
            ans.erase(ans.begin() + i);
            i -= 2;
            // go back 2 steps, to make sure we didn't create another unnecessary move
        }
    }

    // print the answer
    cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; ans.size() &lt;&lt; &quot; moves):&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; ans.size(); i++) {
        cout &lt;&lt; arrows[ans[i]];
        if (i % 5 == 4)
            cout &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>你可能会问：为什么 <code>move()</code> 和 <code>calc()</code> 不能合并在一块儿？<br>
优质答案：<s>我不知道</s>可以，但是我不想改了。<br>
你又会问：为什么你连位运算都改了，却不愿意改这个？<br>
优质答案：去写暑假作业了。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>由 M1 驱动的 MacBook Air 运算。在其他的电脑上，运行时间可能有所不同。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213">https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222">https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>如下图，共 556 份。<br>
<img src="https://oimaster.top/post-images/1688201644902.jpeg" alt="" loading="lazy"> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强连通分量与缩点]]></title>
        <id>https://oimaster.top/post/29iMUCdw4/</id>
        <link href="https://oimaster.top/post/29iMUCdw4/">
        </link>
        <updated>2022-07-30T12:52:56.000Z</updated>
        <summary type="html"><![CDATA[<p>最近复习了关于强连通分量和缩点的知识，有了很多新的感悟，写一篇学习笔记出来供自己查阅。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近复习了关于强连通分量和缩点的知识，有了很多新的感悟，写一篇学习笔记出来供自己查阅。</p>
<!--more-->
<h2 id="强连通分量">强连通分量</h2>
<h3 id="定义">定义</h3>
<p><strong>『强连通』<strong>指的是在一个</strong>有向图</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中，任意两点<strong>连通</strong>，也就是至少存在一条路径。</p>
<p><strong>『强连通分量』</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>指的是尽可能大的『强连通』子图。</p>
<p>例如，在这幅图中，子图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 5, 6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">}</span></span></span></span> 是一个强连通分量，这是因为它们之间两两可达。子图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>3</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mclose">}</span></span></span></span> 与子图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>4</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mclose">}</span></span></span></span> 也是两个大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的强连通分量。</p>
<figure data-type="image" tabindex="1"><img src="https://oimaster.top/post-images/1688220508276.png" alt="" loading="lazy"></figure>
<h3 id="解法">解法</h3>
<p>求解强连通分量问题，有多种算法。本文介绍 Tarjan 算法。首先，需要了解『DFS 生成树』。这是一个示例：</p>
<figure data-type="image" tabindex="2"><img src="https://oimaster.top/post-images/1688220522361.png" alt="" loading="lazy"></figure>
<p>其中，有若干种边。</p>
<ul>
<li><strong>『树边』</strong>：每次搜索到一个没有访问过的节点时会形成一条树边；</li>
<li><strong><span style="color: rgb(255, 0, 0)">『返祖边』</span></strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：指向自己祖先节点的边；</li>
<li><strong><span style="color: rgb(0, 162, 232)">『横叉边』</span></strong>：在搜索中遇到了一个已经访问过的节点，但是这个节点<strong>并不是</strong>自己的祖先；</li>
<li><strong><span style="color: rgb(34, 177, 76)">『前向边』</span></strong>：在搜索时遇到了自己子树中的节点形成，且这个节点已经<strong>被访问过</strong>，即不和自己相邻。</li>
</ul>
<p>对于每个节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为这个节点的 dfs 序。举个例子，在上图中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 被写在了每个节点内部。同时，设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">low_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示在以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 为根的子树中的任意一个点出发，经过<strong>最多一条非子树内的边</strong>后，可以到达的节点中最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>。例如，在上图中，每个节点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 值以红色标到节点旁边。</p>
<figure data-type="image" tabindex="3"><img src="https://oimaster.top/post-images/1688220530168.png" alt="" loading="lazy"></figure>
<p>在搜索之前，先了解一个基本的性质。如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是一个强连通分量内第一个被搜索到的节点，那么这个强连通分量内剩下的所有节点都在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 也被称为这个强连通分量的**『根』**。可以简单地证明一下。</p>
<blockquote>
<p>如果在这个强连通分量内还有一个不同于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 不在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树中，那么因为强连通分量的定义，必须会有一条路径能从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。此时，这条路径上不可能只包含树边，一定还有横叉边或者返祖边。但是横叉边和返祖边的前提是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 一定是已经被搜索到了，不符合『<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是一个强连通分量内第一个被搜索到的节点』，所以这个性质成立。</p>
</blockquote>
<p>在搜索的时候，会遇到几种情况。假设现在搜索到节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>，正看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的相邻节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 没有被访问过。此时递归搜索 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，并直接继承 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">low_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">low_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这是因为如果节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 能访问到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">low_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 只需要多走一条有向边也可以访问到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">low_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以可以直接使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">low_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 取小者；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 已经被访问过。此时又需要分情况讨论：
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 属于一个已知的强连通分量内。此时不需要做任何事情。这是因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 之前属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的强连通分量内，就一定会以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的子树节点出现。这明显是不符合目前的情况的，所以直接忽略。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 不属于一个已知的强连通分量内。根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 值的定义，可以尝试使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">dfn_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">low_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
</ol>
</li>
</ol>
<p>为了判断上面的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 是否在一个已知的强连通分量内，有一种方法是维护一个栈。将一个强连通分量的节点放在一起，当发现后统一弹出并记录。</p>
<p>如何发现一个强连通分量？在一个强连通分量中，必定有且仅有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>u</mi></msub><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">dfn_u = low_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这个节点就是该强连通分量的根。因为在一个强连通分量中，根的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span> 一定最小，所以不会被任何一个强连通分量内的其他节点所影响。</p>
<h3 id="示例">示例</h3>
<p>为了方便理解，不如举个例子。这是原始的图。</p>
<figure data-type="image" tabindex="4"><img src="https://oimaster.top/post-images/1688220539820.png" alt="" loading="lazy"></figure>
<p>从节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 启动搜索。绿色代表正在递归中的边。灰色代表已经搜索过的边。节点内部的数字代表着其编号（为了方便理解，这个编号也等于其 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>），节点旁边的绿色数字为该节点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>。右侧为栈内空间。</p>
<figure data-type="image" tabindex="5"><img src="https://oimaster.top/post-images/1688220549695.png" alt="" loading="lazy"></figure>
<p>按照顺序，接下来应该搜索 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。</p>
<figure data-type="image" tabindex="6"><img src="https://oimaster.top/post-images/1688220686926.png" alt="" loading="lazy"></figure>
<p>按照顺序，接下来应该搜索 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p>
<p><img src="https://oimaster.top/post-images/1688220701852.png" alt="" loading="lazy"><br>
按照顺序，接下来应该搜索 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>。</p>
<figure data-type="image" tabindex="7"><img src="https://oimaster.top/post-images/1688220710460.png" alt="" loading="lazy"></figure>
<p>节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 没有指出去的有向边，无法继续搜索。此时发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>4</mn></msub><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">low_4 = dfn_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，于是判定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>4</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mclose">}</span></span></span></span> 为强连通分量，并弹栈。</p>
<figure data-type="image" tabindex="8"><img src="https://oimaster.top/post-images/1688220714688.png" alt="" loading="lazy"></figure>
<p>回溯到节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p>
<figure data-type="image" tabindex="9"><img src="https://oimaster.top/post-images/1688220718606.png" alt="" loading="lazy"></figure>
<p>此时注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 已经没有更多的有向边指出去，停止拓展。发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>3</mn></msub><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">low_3 = dfn_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>3</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mclose">}</span></span></span></span> 为强连通分量，并弹栈。</p>
<figure data-type="image" tabindex="10"><img src="https://oimaster.top/post-images/1688220725754.png" alt="" loading="lazy"></figure>
<p>回溯到节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。</p>
<figure data-type="image" tabindex="11"><img src="https://oimaster.top/post-images/1688220729587.png" alt="" loading="lazy"></figure>
<p>发现一条有向边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>，于是开始搜索节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>。</p>
<figure data-type="image" tabindex="12"><img src="https://oimaster.top/post-images/1688220733281.png" alt="" loading="lazy"></figure>
<!-- more -->
<p>接下来，搜索节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。发现节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 被访问过且在栈中。根据规则，更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>5</mn></msub><mo>←</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">low_5 \leftarrow dfn_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<figure data-type="image" tabindex="13"><img src="https://oimaster.top/post-images/1688220737923.png" alt="" loading="lazy"></figure>
<p>同样地，搜索节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>。节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 曾被访问过但是不在栈中。根据上面的规则，得知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 一定处在一个已知的强连通分量中，这也是满足示例的。所以不动。</p>
<figure data-type="image" tabindex="14"><img src="https://oimaster.top/post-images/1688220737923.png" alt="" loading="lazy"></figure>
<p>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">low_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">low_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但是因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>3</mn></msub><mo>&gt;</mo><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">low_3 &gt; low_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所以不用做任何事情。接下来，搜索节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。</p>
<figure data-type="image" tabindex="15"><img src="https://oimaster.top/post-images/1688220824138.png" alt="" loading="lazy"></figure>
<p>发现连接节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的有向边。节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 曾经被访问过且在栈中。更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">low_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<figure data-type="image" tabindex="16"><img src="https://oimaster.top/post-images/1688220829577.png" alt="" loading="lazy"></figure>
<p>没有更多的边了。发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>6</mn></msub><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">low_6 \not = dfn_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，不是一个强连通分量。</p>
<p>回溯。</p>
<figure data-type="image" tabindex="17"><img src="https://oimaster.top/post-images/1688220835330.png" alt="" loading="lazy"></figure>
<p>回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 节点。注意此时栈中<strong>不要弹出</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>。用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">low_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">low_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。因为一样大所以不用做任何事情。</p>
<p>没有更多的边了。发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>5</mn></msub><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">low_5 \not = dfn_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，不是一个强连通分量。</p>
<p>回溯。</p>
<figure data-type="image" tabindex="18"><img src="https://oimaster.top/post-images/1688220843814.png" alt="" loading="lazy"></figure>
<p>节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 没有更多的边了。更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub><mo>←</mo><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">low_2 \leftarrow low_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<figure data-type="image" tabindex="19"><img src="https://oimaster.top/post-images/1688220849489.png" alt="" loading="lazy"></figure>
<p>此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 已经没有更多的边。发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">low_2 \not = dfn_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，不是一个强连通分量。</p>
<p>回溯。</p>
<figure data-type="image" tabindex="20"><img src="https://oimaster.top/post-images/1688220856693.png" alt="" loading="lazy"></figure>
<p>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">low_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">low_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但是因为一样大所以什么都不用做。</p>
<p>此时发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">low_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 没有更多边了，于是开始判断。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>1</mn></msub><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">low_1 = dfn_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也就是说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 是某个强连通分量的根。</p>
<p>开始弹栈，直到栈顶为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，并记录下来所弹出来的节点，得到一个新的强连通分量。</p>
<figure data-type="image" tabindex="21"><img src="https://oimaster.top/post-images/1688220864016.png" alt="" loading="lazy"></figure>
<p>注意要连带 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 一起弹出。现在已经探索到了所有的节点。回到主函数。</p>
<figure data-type="image" tabindex="22"><img src="https://oimaster.top/post-images/1688220869716.png" alt="" loading="lazy"></figure>
<p>至此，我们已经找到了所有的强连通分量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 5, 6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">}</span></span></span></span> 、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>3</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mclose">}</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>4</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mclose">}</span></span></span></span>。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-cpp">int n, m;
vector&lt;int&gt; e[10010];

int dfn[10010];
int low[10010];
int cnt;

int sid[10010];
int siz[10010];
int scnt;
bool inStack[10010];
bool vis[10010];
stack&lt;int&gt; st;

void tarjan(int u) {
    vis[u] = true;
    ++cnt;
    dfn[u] = low[u] = cnt;
    st.push(u);
    inStack[u] = true;
    for (auto i : e[u])
        if (!vis[i]) {
            tarjan(i);
            low[u] = min(low[u], low[i]);
        } else if (inStack[i])
            low[u] = min(low[u], dfn[i]);
    if (dfn[u] == low[u]) {
        ++scnt;
        while (st.top() != u) {
            sid[st.top()] = scnt;
            ++siz[scnt];
            inStack[st.top()] = false;
            st.pop();
        }
        st.pop();
        sid[u] = scnt;
        ++siz[scnt];
        inStack[u] = false;
    }
}
</code></pre>
<h2 id="缩点">缩点</h2>
<p>没什么技巧，就是把强连通分量的环当作一个新的点，重新构造一遍图即可。注意不要出现自环。</p>
<p>构造出来的一定是一个 DAG<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-cpp">for (int i = 1; i &lt;= n; ++i) e[i].clear();
for (int i = 1; i &lt;= m; ++i) {
    int u = sid[ex[i]];
    int v = sid[ey[i]];
    if (u != v)
        e[u].push_back(v);
}
</code></pre>
<h2 id="习题">习题</h2>
<h3 id="缩点模板">缩点模板</h3>
<h4 id="题目描述">题目描述</h4>
<p>链接：<a href="https://www.luogu.com.cn/problem/P3387">https://www.luogu.com.cn/problem/P3387</a></p>
<h4 id="解法-2">解法</h4>
<p>完成 Tarjan、缩点后，跑一遍拓扑排序就可以解决。</p>
<h4 id="代码实现">代码实现</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, m;
int a[10010];
vector&lt;int&gt; e[10010];
int ex[100010];
int ey[100010];

int dfn[10010];
int low[10010];
bool inStack[10010];
bool vis[10010];
stack&lt;int&gt; st;
int cnt;

vector&lt;int&gt; newe[10010];
int sid[10010];
int siz[10010];
int scnt;

queue&lt;int&gt; topo;
int dis[10010];
int deg[10010];

int ans;

void tarjan(int u) {
    vis[u] = true;
    ++cnt;
    dfn[u] = cnt;
    low[u] = cnt;
    st.push(u);
    inStack[u] = true;

    for (auto i : e[u])
        if (vis[i] == false) {
            tarjan(i);
            low[u] = min(low[u], low[i]);
        } else if (inStack[i] == true)
            low[u] = min(low[u], dfn[i]);

    if (dfn[u] == low[u]) {
        ++scnt;
        while (st.top() != u) {
            sid[st.top()] = scnt;
            siz[scnt] += a[st.top()];
            inStack[st.top()] = false;
            st.pop();
        }
        st.pop();
        sid[u] = scnt;
        siz[scnt] += a[u];
        inStack[u] = false;
    }
}

void toposort() {
    for (int i = 1; i &lt;= scnt; ++i)
        if (deg[i] == 0) {
            dis[i] = siz[i];
            topo.push(i);
        }

    while (!topo.empty()) {
        int now = topo.front();
        topo.pop();

        for (auto i : newe[now]) {
            dis[i] = max(dis[i], dis[now] + siz[i]);
            --deg[i];
            if (deg[i] == 0)
                topo.push(i);
        }
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= m; ++i) {
        cin &gt;&gt; ex[i] &gt;&gt; ey[i];
        e[ex[i]].push_back(ey[i]);
    }

    for (int i = 1; i &lt;= n; ++i)
        if (dfn[i] == 0)
            tarjan(i);

    for (int i = 1; i &lt;= m; ++i) {
        int u = sid[ex[i]];
        int v = sid[ey[i]];

        if (u != v) {
            newe[u].push_back(v);
            ++deg[v];
        }
    }

    toposort();
    for (int i = 1; i &lt;= scnt; ++i) ans = max(ans, dis[i]);

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>这是一个比较有用的算法。不少图论问题可以通过 Tarjan 转换成 DAG，然后进行拓扑排序等操作，可以在图上进行动态规划。</p>
<p>在 <a href="/post/Zfjel35ew/">之前的一篇文章</a> 中，并未详细解释这棵『DFS 生成树』，只是称为『一棵树』<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>了之。读者不妨回头看看，可能会有更深的收获。</p>
<p>另外，请让我说一句，『这些图片真的累死我了』！</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Strongly Connected Components，缩写为 SCC。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>也可以称为『后向边』、『回边』，英文为『back edge』。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Directed Acyclic Graph，有向无环图。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>『可以将一张图看作一棵树』。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[割点与桥]]></title>
        <id>https://oimaster.top/post/Zfjel35ew/</id>
        <link href="https://oimaster.top/post/Zfjel35ew/">
        </link>
        <updated>2022-07-28T10:15:07.000Z</updated>
        <summary type="html"><![CDATA[<p>最近学习了关于割点和桥的知识，写一篇学习笔记出来供自己复习。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近学习了关于割点和桥的知识，写一篇学习笔记出来供自己复习。</p>
<!--more-->
<h2 id="割点">割点</h2>
<h3 id="定义">定义</h3>
<p>在一个<strong>无向图</strong>中，如果删除一个点以及与它相邻的边后，图中的连通块数量增加，那么就称这个点为**『割点』**。</p>
<p>这里有一张图，可以更清楚地理解一下。</p>
<figure data-type="image" tabindex="1"><img src="https://oimaster.top/post-images/1688221349035.png" alt="" loading="lazy"></figure>
<p>在这张图中，如果删除了节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，那么图就会变成这样：</p>
<figure data-type="image" tabindex="2"><img src="https://oimaster.top/post-images/1688221354834.png" alt="" loading="lazy"></figure>
<p>图中的连通块个数从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，可见节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 就是这张图的『割点』。</p>
<h3 id="解法">解法</h3>
<p>求解图中的割点，可以使用 Tarjan 算法。</p>
<p>首先，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的 dfs 序。通过 dfs，可以将一张图看作一棵树。刚才的图可以被标记成这样。其中，再节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 旁边的红色数字代表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，被红色标记的边为树上的边。</p>
<figure data-type="image" tabindex="3"><img src="https://oimaster.top/post-images/1688221359693.png" alt="" loading="lazy"></figure>
<p>接下来，对于每一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">low_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示从点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树中的任意一个点出发，经过<strong>最多一条非子树内的边</strong>后，可以到达的节点中最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>为了方便查看，我整理了一下这张图，使它看上去像棵树。</p>
<figure data-type="image" tabindex="4"><img src="https://oimaster.top/post-images/1688221364586.png" alt="" loading="lazy"></figure>
<p>举个例子，在上图中，如果把节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 看作根，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 数组的值就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, 1, 1, 1, 1, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span>。</p>
<p>为了方便理解，我解释一下为什么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">low_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 的子树中，只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 一个节点。也就是说，边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(5, 6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span> 并不属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 子树内的一条边。所以，能去到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span> 最小的节点编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(5, 6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span> 一条非子树边，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>6</mn></msub><mo>←</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">low_6 \leftarrow dfn_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>同样地，对于节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，它的子树中有节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2, 3, 4, 5, 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span></span></span></span>。可以得到的最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span> 便是通过子树边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(5,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，再经过一条非子树边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(3, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 到达节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。于是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mn>2</mn></msub><mo>←</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">low_2 \leftarrow dfn_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<strong>注意这里无法直接从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 到达节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 并不是一条以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 为根的子树边。</strong></p>
<p>所以，如果节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树中存在一点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>j</mi></msub><mo>≥</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">low_j \ge dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么就可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 一定是一个割点。原因是，根据上面的定义，如果要从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 到任何一个满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>k</mi></msub><mo>&lt;</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dfn_k &lt; dfn_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，<strong>是没有办法直接从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的子树到达的</strong>，必须通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。因此，如果删除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 就无法互相到达了，连通块数量增加，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是一个割点。</p>
<p>但是有一个点是特殊的，这就是整棵树的<strong>根</strong>。这个节点无法通过上面的方法解决，因为它不是任何节点的孩子。不过也不困难。如果根节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个及以上的子树，那么如果切断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这些子树将无法连接。注意，<strong>子树之间是不可能有边连接的</strong>，这是因为在获得子树的 dfs 中，能与一棵子树相连的节点<strong>全都会被归到一个子树中</strong>。</p>
<h3 id="代码">代码</h3>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3388">https://www.luogu.com.cn/problem/P3388</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
int n, m;
vector&lt;int&gt; e[20010];
vector&lt;int&gt; p;
int dfn[20010];
int low[20010];
int cnt;
void tarjan(int u, bool root) {
    int tot = 0;
    // dfs 序
    ++cnt;
    dfn[u] = cnt;
    low[u] = cnt;
    for (auto i : e[u])
        if (dfn[i])
            low[u] = min(low[u], dfn[i]); // i 不是 u 的子树。(i, u) 是一条非子树边。
        else {
            tarjan(i, false);
            low[u] = min(low[u], low[i]); // i 是 u 的子树，所以 u 可以直接收取 i 的答案。
            if (low[i] &gt;= dfn[u])
                ++tot;
        }
    if ((root == true &amp;&amp; tot &gt; 1) || (root == false &amp;&amp; tot &gt; 0))
        p.push_back(u);
}
int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for (int i = 1; i &lt;= n; ++i)
        if (dfn[i] == 0)
            tarjan(i, true);
    for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; dfn[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; low[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    sort(p.begin(), p.end());
    cout &lt;&lt; p.size() &lt;&lt; endl;
    for (auto i : p) cout &lt;&lt; i &lt;&lt; ' ';
    cout &lt;&lt; endl;
}
</code></pre>
<h2 id="桥">桥</h2>
<h3 id="定义-2">定义</h3>
<p>在一个<strong>无向图</strong>中，如果删除一条边后，图中的连通块数量增加，那么就称这条边为**『桥』**<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<p>这里还是那张图，可以更清楚地理解一下。</p>
<figure data-type="image" tabindex="5"><img src="https://oimaster.top/post-images/1688221376445.png" alt="" loading="lazy"></figure>
<p>在这张图后，如果删除了边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(5, 6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span>，那么图会变成这样：</p>
<figure data-type="image" tabindex="6"><img src="https://oimaster.top/post-images/1688221397598.png" alt="" loading="lazy"></figure>
<p>图中的连通块个数从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 变成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，可见边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(5, 6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span> 就是这张图的『桥』。</p>
<h3 id="解法-2">解法</h3>
<p>与刚才的解法类似。</p>
<p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的定义稍微修改一下，修改的地方加粗显示。对于每一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">low_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示从点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的子树中的任意一个点出发，经过最多一条非子树内的边<strong>且这条边不连接自己的父亲</strong>，可以到达的节点中最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>对于修改后的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，可以得到，如果节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 是节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的父亲，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>u</mi></msub><mo>&lt;</mo><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">dfn_u &lt; low_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 是桥。</p>
<p>理由：假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 不是桥，那么当删除边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 一定可以通过连接自己子树的一些边<strong>跳到</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span> 小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的点。要想这样，就会有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>u</mi></msub><mo>≥</mo><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">dfn_u \ge low_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，与上面的式子矛盾了。所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 一定是桥。</p>
<p>那么为什么需要修改定义？如果不修改定义，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 一定可以通过连接自己父亲的边<strong>直接</strong>跳到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>，就<strong>不可能</strong>找到任何的桥。</p>
<h3 id="代码-2">代码</h3>
<p>提交链接暂时没有。</p>
<p><strong>如果有重边的话，下面的代码就不能通过了。<strong>这是因为如果有重边的话，代码第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>17</mn></mrow><annotation encoding="application/x-tex">17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span> 行就会</strong>忽略掉重边</strong>。解决这个问题可以通过链式前向星等存储无向图，使得正向边与反向边<strong>存在一起</strong>，拿到边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">id</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> 后通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>⊕</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">id \oplus 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 等操作判断是否<strong>属于一条无向边</strong>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊕</span></span></span></span> 表示异或。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
int n, m;
vector&lt;int&gt; e[20010];
vector&lt;pair&lt;int, int&gt;&gt; p;
int dfn[20010];
int low[20010];
int cnt;
void tarjan(int u, int fa) {
    ++cnt;
    dfn[u] = cnt;
    low[u] = cnt;
    for (auto i : e[u])
        if (dfn[i]) {
            if (i == fa) // 更改定义，忽略掉与父亲连接的边。前提是没有重边
                continue;
            low[u] = min(low[u], dfn[i]);
        } else {
            tarjan(i, u);
            low[u] = min(low[u], low[i]);
            if (low[i] &gt; dfn[u]) // 细微的更改
                p.emplace_back(u, i);
        }
}
int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= m; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for (int i = 1; i &lt;= n; ++i)
        if (dfn[i] == 0)
            tarjan(i, 0);
    sort(p.begin(), p.end());
    cout &lt;&lt; p.size() &lt;&lt; endl;
    for (auto i : p) cout &lt;&lt; i.first &lt;&lt; '-' &lt;&lt; i.second &lt;&lt; ' ';
    cout &lt;&lt; endl;
}
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>桥也叫做割边。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>