<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>用计算机解决 15 数码问题 | oimaster</title>

<link rel="shortcut icon" href="https://oimaster.top/favicon.ico?v=1688999066099">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://oimaster.top/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4124390044128578"
     crossorigin="anonymous"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3LHKWZN2MD"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());
        gtag('config', 'G-3LHKWZN2MD');
    </script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            oimaster
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top/friends" class="menu gt-a-link">
                            友链
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://oimaster.top/tag/rPyI6irTc/" class="menu gt-a-link">
                            日报
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1688999066099" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    用计算机解决 15 数码问题
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-07-01 ·
                    </time>
                    
                        <a href="https://oimaster.top/tag/dckx_hRvn/" class="post-tags">
                            # 程序
                        </a>
                    
                        <a href="https://oimaster.top/tag/fKwrK_94Kv/" class="post-tags">
                            # 搜索
                        </a>
                    
                        <a href="https://oimaster.top/tag/e--aFoX350/" class="post-tags">
                            # A*
                        </a>
                    
                        <a href="https://oimaster.top/tag/j0HkJQp5jG/" class="post-tags">
                            # 15 数码
                        </a>
                    
                        <a href="https://oimaster.top/tag/es_3JasRPm/" class="post-tags">
                            # 数学
                        </a>
                    
                        <a href="https://oimaster.top/tag/O-IBmBzFgU/" class="post-tags">
                            # 位运算
                        </a>
                    
                        <a href="https://oimaster.top/tag/9oxZbER2at/" class="post-tags">
                            # C++
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>期末考试阶段，有不少压力。这时候，看到了一个小玩具。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://oimaster.top/post-images/1688193736552.jpeg" alt="" loading="lazy"></figure>
<p>我认为这有助于我放松。于是，我尝试解决它。然而，这花了我 5 分钟左右。</p>
<p>我感到很不服气。我打算征服它。</p>
<h2 id="宽广度优先搜索">宽（广）度优先搜索</h2>
<p>我打算使用电脑提升解题速度。刚开始，我认为这不难，应该在二十几步内完成。</p>
<p>此时，使用深度优先搜索显然不适合，因为在一步错误下很可能分叉出很多种可能。于是我打算用宽搜。</p>
<p>因为才完成一个 Vue 项目，所以我顺手写了一点 JS 代码（现在被我删了，很可惜你们看不到）。当我按下回车后，我的 Node.js 瞬间卡死了。</p>
<p>我以为可能是 Javascript 执行速度太慢，就重写了一份 C++ 代码。仍然很慢。已经到了深夜，我便回去复习了。</p>
<h2 id="a">A*</h2>
<p>这事情本来结束了的，然而我在晚上玩耍时看到了一个网站。</p>
<iframe src="https://dpxx.github.io/" width="100%" height="750"></iframe>
<p>它提供的样例是 <code>5,1,4,7,2,11,3,8,9,6,14,15,13,10,0,12</code>，一共有 19 步，但是它瞬间就解决了。</p>
<p>我查看了它的源代码。它使用了启发式搜索。我不能落后。</p>
<p>因为 C++ 里面提供了 priority_queue，再加上 Javascript 在复杂计算时太慢了，所以我优先使用 C++。</p>
<p>思路是这样的：</p>
<ul>
<li>对于每一个节点，遍历所有的数码；</li>
<li>对于每一个数码，计算数码应该在的位置；</li>
<li>接下来，计算当前位置与正确位置的距离，并累加。</li>
</ul>
<p>这样，得到了节点的分数。据此进行 A*。</p>
<p>另外，因为使用一整个数组搜索太不方便，我使用了 <code>getHash()</code> 函数进行哈希。实际上，由于我用的是 <code>unsigned long long</code> 类型，所以不需要取模，也不会有重复的数值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;

#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

bool isValid(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    // verify size
    if (puzzle.size() != 4)
        return false;
    for (int i = 0; i &lt; 4; i++) {
        if (puzzle[i].size() != 4)
            return false;
    }

    bool exist[16] = { false };
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            if (puzzle[i][j] &lt; 0 || puzzle[i][j] &gt; 15)
                return false;
            if (exist[puzzle[i][j]])
                return false;
            exist[puzzle[i][j]] = true;
        }
    }

    return true;
}

unsigned long long getHash(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    unsigned long long hash = 0;
    for (int i = 0; i &lt; 16; i++) {
        hash = hash * 16 + puzzle[i / 4][i % 4];
    }
    return hash;
}

int getScore(vector&lt;vector&lt;int&gt;&gt; puzzle) {
    int score = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            if (puzzle[i][j] == 0)
                continue;
            score += abs(i - (puzzle[i][j] - 1) / 4) + abs(j - (puzzle[i][j] - 1) % 4);
        }
    }
    return score;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; puzzle(4, vector&lt;int&gt;(4));

    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j];
    }

    int time = clock();

    if (!isValid(puzzle)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl;
        return 0;
    }

    // A* search
    priority_queue&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;, vector&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;,
                   greater&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt;
        pq;
    set&lt;unsigned long long&gt; visited;
    pq.push(make_pair(getScore(puzzle), puzzle));
    visited.insert(getHash(puzzle));

    map&lt;unsigned long long, unsigned long long&gt; parent;
    map&lt;unsigned long long, char&gt; direction;
    map&lt;unsigned long long, int&gt; depth;
    map&lt;unsigned long long, int&gt; cost;

    while (!pq.empty()) {
        vector&lt;vector&lt;int&gt;&gt; cur = pq.top().second;
        pq.pop();

        if (getScore(cur) == 0) {
            // print solution
            vector&lt;unsigned long long&gt; path;
            unsigned long long curHash = getHash(cur);
            while (curHash != getHash(puzzle)) {
                path.push_back(curHash);
                curHash = parent[curHash];
            }
            reverse(path.begin(), path.end());

            cout &lt;&lt; &quot;Solution:&quot; &lt;&lt; endl;
            for (int i = 0; i &lt; path.size(); i++) {
                cout &lt;&lt; direction[path[i]];
                if (i % 5 == 4)
                    cout &lt;&lt; ' ';
            }
            cout &lt;&lt; endl;

            cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1.0 / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
            return 0;
        }

        int curDepth = depth[getHash(cur)];
        int curCost = cost[getHash(cur)];

        int zeroX = -1, zeroY = -1;
        for (int i = 0; i &lt; 4; i++) {
            for (int j = 0; j &lt; 4; j++) {
                if (cur[i][j] == 0) {
                    zeroX = i;
                    zeroY = j;
                    break;
                }
            }
        }

        // move up
        if (zeroX &gt; 0) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX - 1][zeroY]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'U';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move down
        if (zeroX &lt; 3) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX + 1][zeroY]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'D';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move left
        if (zeroY &gt; 0) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX][zeroY - 1]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'L';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }

        // move right
        if (zeroY &lt; 3) {
            vector&lt;vector&lt;int&gt;&gt; next = cur;
            swap(next[zeroX][zeroY], next[zeroX][zeroY + 1]);
            unsigned long long nextHash = getHash(next);
            if (visited.find(nextHash) == visited.end()) {
                visited.insert(nextHash);
                parent[nextHash] = getHash(cur);
                direction[nextHash] = 'R';
                depth[nextHash] = curDepth + 1;
                cost[nextHash] = curCost + 1;
                pq.push(make_pair(curCost + 1 + getScore(next), next));
            }
        }
    }

    cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>运行起来大概是这样的<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<pre><code class="language-bash">oimaster@kafuu 23-07-01 16:02:33 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b   
oimaster@kafuu 23-07-01 16:02:45 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
9 5 1 4
3 7 2 8
6 0 10 11
13 14 15 12
Solution:
ULURR DLDLU URRDL DRRD
Time: 1.758ms
</code></pre>
<p>然后我就发了条空间。</p>
<figure data-type="image" tabindex="2"><img src="https://oimaster.top/post-images/1688195588821.png" alt="" loading="lazy"></figure>
<h2 id="快一点的-a">快一点的 A*</h2>
<p>当我发出去后，我意识到自己的行为十分愚蠢。A* 算法很多人都会。然而，因为我使用了大量的 STL，但是编译时连 <code>-O2</code> 都没有加上，所以很容易被超越。</p>
<p>吓得我赶紧加上了 <code>-Ofast</code>。可以发现确实快了不少。</p>
<pre><code class="language-sh">oimaster@kafuu 23-07-01 16:24:10 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b       
oimaster@kafuu 23-07-01 16:24:16 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
3 5 7 4
6 9 2 12
0 13 11 14
10 1 8 15
Solution:
DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD
Time: 1438.26ms
oimaster@kafuu 23-07-01 16:24:19 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b -Ofast
oimaster@kafuu 23-07-01 16:24:29 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out
3 5 7 4
6 9 2 12
0 13 11 14
10 1 8 15
Solution:
DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD
Time: 265.271ms
oimaster@kafuu 23-07-01 16:24:32 ~/Documents/code/puzzle &gt;&gt;&gt; 
</code></pre>
<p>立刻发了条空间刷新我的记录。两条空间间隔不到十分钟。显然是加了点编译优化选项，改不了多少代码。</p>
<figure data-type="image" tabindex="3"><img src="https://oimaster.top/post-images/1688196144848.png" alt="" loading="lazy"></figure>
<h2 id="位运算版-a">位运算版 A*</h2>
<p>如上面所说，第二天下午，我就去写了位运算。这个比较麻烦。首先，让我们思考如何表示一个棋盘。</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _
</code></pre>
<p>将所有的空格换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么可以发现所有的数字都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>16</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left[0, 16\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 中的整数，很方便位运算。</p>
<p>按照从上到下，从左到右的顺序，就可以把上面的棋盘转换成十六进制：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mo fence="true">(</mo><mn>123456789</mn><mi>a</mi><mi>b</mi><mi>c</mi><mi>d</mi><mi>e</mi><mi>f</mi><mn>0</mn><mo fence="true">)</mo></mrow><mn>16</mn></msub><mo>=</mo><msub><mrow><mo fence="true">(</mo><mn>1311768467463790320</mn><mo fence="true">)</mo></mrow><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">\left(123456789abcdef0\right)_{16} = \left(1311768467463790320\right)_{10}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span><span class="mord">8</span><span class="mord">9</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">6</span><span class="mord">3</span><span class="mord">7</span><span class="mord">9</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，每一个数位代表着一个位置上的数字。</p>
<p>对于这个大数字，我们思考如何存储它。<code>unsigned long long</code> 可以吗？它的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0, 2^{64}-1\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span>，也就是一直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18446744073709551615</mn></mrow><annotation encoding="application/x-tex">18446744073709551615</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">4</span><span class="mord">0</span><span class="mord">7</span><span class="mord">3</span><span class="mord">7</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord">5</span><span class="mord">1</span><span class="mord">6</span><span class="mord">1</span><span class="mord">5</span></span></span></span>。远远大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1311768467463790320</mn></mrow><annotation encoding="application/x-tex">1311768467463790320</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">1</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord">4</span><span class="mord">6</span><span class="mord">7</span><span class="mord">4</span><span class="mord">6</span><span class="mord">3</span><span class="mord">7</span><span class="mord">9</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span></span></span></span>，放心吧。</p>
<p>所以就可以写出输入：</p>
<pre><code class="language-cpp">#define puzzle unsigned long long

puzzle p = 0;
for (int i = 0; i &lt; 16; i++) {
    int x;
    cin &gt;&gt; x;
    p = (p &lt;&lt; 4) + x;
}
</code></pre>
<p>接下来，就是处理移动。这将会是一个大工程。首先，让我们找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 所在的数位。</p>
<pre><code class="language-cpp">int zero = 0;
while (((x &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++;
</code></pre>
<p>如果我们要向上方移动，横着看，我们就需要向前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个数位。例如，我们要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上移：</p>
<pre><code>123456789abcdef0
               ^
123456789ab0defc
           ^
</code></pre>
<p>其本质是：</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _

1 2 3 4
5 6 7 8
9 10 11 _
13 14 15 12
</code></pre>
<p>于是，你就可以写出代码，获取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上方的数字是多少：</p>
<pre><code class="language-cpp">int top = zero + 4;
int dig = (x &gt;&gt; (top &lt;&lt; 2)) &amp; 15;
</code></pre>
<p>奇怪，第一行为什么是 <code>zero + 4</code> 而不是 <code>zero - 4</code> 呢？不知道你们有没有发现，我们的数位是<strong>颠倒</strong>的。所以正确的移动其实是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 位到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 位。：</p>
<pre><code>123456789abcdef0
               ^
               0

123456789ab0defc
           ^
           4
</code></pre>
<p>不过到目前为止，我们只是获取到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mo>←</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">dig \leftarrow 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>。我们还需要把这个数字移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 原来所在的位置。</p>
<pre><code class="language-cpp">x |= (unsigned long long)dig &lt;&lt; (zero &lt;&lt; 2);
</code></pre>
<p>这行代码使用「或」运算，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的二进制全部为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，所以或运算本质上就是拷贝。</p>
<p>于此同时，我们还需要把原来上方的格子清零。我们需要「与」运算。运算时，我们需要保证上方的格子对应「0」从而删除，而其他的位置不变。于是自然又会想到将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mo fence="true">(</mo><mn>15</mn><mo fence="true">)</mo></mrow><mn>10</mn></msub><mo>=</mo><msub><mrow><mo fence="true">(</mo><mn>1111</mn><mo fence="true">)</mo></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\left(15\right)_{10} = \left(1111\right)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span></span></span></span> 移动到那一位，同时取反，让其他位变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>——不干扰。</p>
<p>于是写出：</p>
<pre><code class="language-cpp">x &amp;= ~((unsigned long long)15 &lt;&lt; (top &lt;&lt; 2));
</code></pre>
<p>整理一下上方所有的位运算，压到一行里：</p>
<pre><code class="language-cpp">x = (x | ((x &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2)) &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2));
</code></pre>
<p>搞定！其他方向同理，于是我们就可以写出搜索时的代码。</p>
<h3 id="判断无解">判断无解</h3>
<p>为了方便我的时间测量，防止没必要的浪费，我有必要写出来判断无解的代码。</p>
<p>让我们观察一下有解的几种情况。</p>
<pre><code>1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 _

1 2 3 4
5 6 7 8
9 10 11 12
13 14 _ 15

1 2 3 4
5 6 7 8
9 10 11 _
13 14 15 12
</code></pre>
<p>为了方便处理，我们可以把二维转为一维，和之前一样，从上到下，从左到右。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>0</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>从数列中删去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，得到了：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\right] \\
\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>你会发现，第一行和第二行没有变化。第三行相对两者来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> 移动到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[13, 14, 15\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span> 的后方，创造了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个逆序对。</p>
<p>让我们再把空格往上移动一下。</p>
<pre><code>1 2 3 4
5 6 7 _
9 10 11 8
13 14 15 12
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 8, 13, 14, 15, 12\right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p>
<p>注意到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 向后移动了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 格，创造了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个逆序对，此时共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 个逆序对。</p>
<p>仔细观察，会发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的坐标与逆序对的奇偶性有关系。每当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 向上移动奇数行（所在坐标也为奇数行），逆序对的数量为奇数。反之，在偶数行时，逆序对的数量为偶数。</p>
<p>对于左右移动，不影响序列，所以我们不必考虑。</p>
<p>和位运算周旋半个小时就可以写出下面的代码：</p>
<pre><code class="language-cpp">bool hasSolution(puzzle p) {
    int cnt = 0, zeroX = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0) {
            zeroX = i &gt;&gt; 2;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15;
            if (y == 0)
                continue;
            if (y &lt; x)
                cnt++;
        }
    }
    return ((cnt + zeroX) &amp; 1) == 0;
}
</code></pre>
<p>最后写完整代码时发现之前的 <code>cost</code> 没有任何作用，就删掉了。另外，为了加快速度，我改成了 <code>unordered_map</code> 和 <code>unordered_set</code>。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;

using namespace std;

#define puzzle unsigned long long

inline bool isValid(puzzle p) {
    unsigned exist = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = p &amp; 15;
        if (x &lt; 0 || x &gt; 15)
            return false;
        if (exist &amp; (1llu &lt;&lt; x))
            return false;
        exist |= (1llu &lt;&lt; x);
        p &gt;&gt;= 4;
    }
    return true;
}

unsigned getScore(puzzle p) {
    unsigned score = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0)
            continue;
        score += abs((i &gt;&gt; 2) - ((x - 1) &gt;&gt; 2)) + abs((i &amp; 3) - ((x - 1) &amp; 3));
    }
    return score;
}

bool hasSolution(puzzle p) {
    int cnt = 0, zeroX = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15;
        if (x == 0) {
            zeroX = i &gt;&gt; 2;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15;
            if (y == 0)
                continue;
            if (y &lt; x)
                cnt++;
        }
    }
    return ((cnt + zeroX) &amp; 1) == 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    puzzle p = 0;
    for (int i = 0; i &lt; 16; i++) {
        int x;
        cin &gt;&gt; x;
        p = (p &lt;&lt; 4) + x;
    }

    int time = clock();

    if (!isValid(p)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl
             &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
        return 0;
    }

    if (!hasSolution(p)) {
        cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl
             &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
        return 0;
    }

    priority_queue&lt;pair&lt;unsigned, puzzle&gt;, vector&lt;pair&lt;unsigned, puzzle&gt;&gt;, greater&lt;pair&lt;unsigned, puzzle&gt;&gt;&gt;
        pq;
    unordered_map&lt;puzzle, puzzle&gt; parent;
    unordered_map&lt;puzzle, char&gt; direction;
    unordered_map&lt;puzzle, unsigned&gt; depth;

    pq.push(make_pair(0, p));
    depth[p] = 1;

    while (!pq.empty()) {
        puzzle curr = pq.top().second;
        pq.pop();

        if (curr == 0x123456789abcdef0llu) {
            stack&lt;char&gt; path;
            while (curr != p) {
                path.push(direction[curr]);
                curr = parent[curr];
            }

            cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; path.size() &lt;&lt; &quot; steps):&quot; &lt;&lt; endl;
            int cnt = 0;
            while (!path.empty()) {
                cout &lt;&lt; path.top() &lt;&lt; (((++cnt) % 5 == 0) ? &quot; &quot; : &quot;&quot;);
                path.pop();
            }
            cout &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
            return 0;
        }

        unsigned currDepth = depth[curr];

        int zero = 0;
        while (((curr &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++;

        if (zero &lt; 12) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'D';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if (zero &gt; 3) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 4) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero - 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'U';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if ((zero &amp; 3) != 3) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 1) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero + 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'R';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }

        if ((zero &amp; 3) != 0) {
            puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 1) &lt;&lt; 2))) |
                          ((curr &gt;&gt; ((zero - 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2);
            if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) {
                depth[next] = currDepth + 1;
                parent[next] = curr;
                direction[next] = 'L';
                pq.push(make_pair(getScore(next) + currDepth + 1, next));
            }
        }
    }

    cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><s>我又提供了一份提高组的阅读程序代码。考察重点：位运算；难度★★★★★。</s></p>
<p>它运行起来，更快了。看到它运行起来，我更快乐。你无法想象这东西我调试了多久。</p>
<figure data-type="image" tabindex="4"><img src="https://oimaster.top/post-images/1688199346710.png" alt="" loading="lazy"></figure>
<p>位运算确实提升了不少。</p>
<h2 id="更快的方法">更快的方法</h2>
<p>至此，搜索我们基本到头了。但是在一些复杂的题目上，仍然要花几分钟才能算出。</p>
<p>我们是想要什么？是要最优解吗？那么搜索当然可以。</p>
<p>但我的目标不是这个。我的目标是在做任何题目的时候都快速解决，但是步数没有太大要求。</p>
<p>wikiHow，该你出场了：<a href="https://www.wikihow.com/Solve-a-15-Puzzle">https://www.wikihow.com/Solve-a-15-Puzzle</a></p>
<p><strong>请读者先自行阅读上方文章。</strong></p>
<p>一切都很轻松，除了几个问题，需要我们细化。</p>
<ol>
<li>人类很容易移动，那么计算机怎么办？如何从机械的角度看待「移动」的过程？</li>
<li>文中 3.2 说：「Place 9 on the right side of 13.  Move 13 temporarily if you have to.」<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>什么时候叫做「if you have to.」？我又该如何移动？</li>
<li>最后一步「If they don't go to their original places, do method 3 again by mixing only the last two rows.」<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>有何意义？</li>
</ol>
<p>然后，我们来进行解决。</p>
<h3 id="问题-1">问题 1</h3>
<p>将一个数码往上移，本质上是将空格移动到其上方，然后再将空格移动到原数码的位置。这是因为每次移动空格本质上是与相邻的数码交换位置。</p>
<h3 id="问题-2">问题 2</h3>
<p>通过玩实体的 15 数码，我发现有 2 种情况需要移动「13」。分别是（<code>?</code> 代表任意数字，包括空格；<code>_</code> 代表空格，此时 <code>?</code> 不包括空格）：</p>
<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
9 ? ? ?
</code></pre>
<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
_ 9 ? ?
</code></pre>
<p>这两种情况很容易互相转换。可以这样：</p>
<ol>
<li>将右侧 6 个 <code>?</code> 中的空格移动到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的右侧，得到：<pre><code>1 2 3 4
5 6 7 8
13 ? ? ?
9 _ ? ?
</code></pre>
</li>
<li>移动「9」。</li>
</ol>
<p>此时，因为每当尝试将「9」改变位置时必将堵死，所以需要「13」移动。移动的方法，我总结出来以下的结果：</p>
<ol>
<li>允许改动「13」的位置，将「9」移动到第三行、第三列（即原来「11」所在的位置）。</li>
<li>在将「9」保持不动的情况下，利用左下角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的空间将「13」归回原位。</li>
<li>移动「9」到第三行，第二列，完成此步骤。</li>
</ol>
<p>因为第三行、第三列并不在左下角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的空间内，所以现在移动「13」的时候必将不会干扰「9」。</p>
<h3 id="问题-3">问题 3</h3>
<p>一句话：实践表明，<strong>没必要</strong>。</p>
<h3 id="代码实现">代码实现</h3>
<p>首先，我对于每一个格子都给予编号。</p>
<pre><code>0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
</code></pre>
<p>接下来，我对于当前重要的格子和已经解决的格子，赋予 <code>blocked</code> 属性。</p>
<p>在 <code>vector&lt;int&gt; findPath(int from, int to);</code> 中，程序会通过宽度优先搜索，给出一条 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo>→</mo><mi>t</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">from \rightarrow to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span></span></span></span> 的路径，不经过 <code>blocked</code> 指定的格子。</p>
<p>在 <code>vector&lt;int&gt; move(Puzzle puzzle, int from, int to);</code> 中，程序会多次调用 <code>findpath()</code>，将在 <code>from</code> 位置上的<strong>数码</strong>移动到 <code>to</code>，即包括了空格子的计算。</p>
<p>在 <code>bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to);</code> 中，程序会记录答案，并返回是否成功。</p>
<p>更多的内容，请参照注释。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
using namespace std;

typedef vector&lt;vector&lt;int&gt;&gt; Puzzle;
#define cell2num(x, y) ((x)*4 + (y))

// check if the puzzle is valid
bool isValid(Puzzle puzzle) {
    vector&lt;bool&gt; exist(16, false);
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] &lt; 0 || puzzle[i / 4][i % 4] &gt; 15)
            return false;
        if (exist[puzzle[i / 4][i % 4]])
            return false;
        exist[puzzle[i / 4][i % 4]] = true;
    }
    return true;
}

// get if the puzzle has solution
bool hasSolution(Puzzle puzzle) {
    int inversions = 0;
    int zeroRow = 0;
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] == 0) {
            zeroRow = i / 4;
            continue;
        }
        for (int j = 0; j &lt; i; j++) {
            if (puzzle[j / 4][j % 4] == 0)
                continue;
            if (puzzle[j / 4][j % 4] &gt; puzzle[i / 4][i % 4])
                inversions++;
        }
    }
    return (inversions + zeroRow) % 2 == 1;
    // the index starts from 0, so the result of inversions should be ~~even~~ -&gt; odd
}

vector&lt;vector&lt;bool&gt;&gt; blocked(4, vector&lt;bool&gt;(4, false));
// the cells that have been already solved will be blocked

const string arrows[4] = { &quot;↑&quot;, &quot;↓&quot;, &quot;←&quot;, &quot;→&quot; };
const int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
// opposite to the arrows, because when we play the game, we don't move the empty cell, but move the numbers
// but in the code, we move the empty cell, so the direction is opposite to the arrows

// get the position of the number
int getPos(Puzzle puzzle, int num) {
    for (int i = 0; i &lt; 16; i++) {
        if (puzzle[i / 4][i % 4] == num)
            return i;
    }
    return -1;
}

// find the path from the start to the end, do not need the puzzle itself, but 'blocked' is needed
vector&lt;int&gt; findPath(int from, int to) {
    queue&lt;int&gt; q;

    vector&lt;int&gt; parent(16, -1);
    // the parent of the cell, -1 means not visited, -2 means the start cell

    q.push(from);
    parent[from] = -2;

    // using BFS to find the path, can be replaced by A*
    // but it's not necessary since the puzzle is small
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        if (cur == to)
            break;
        int x = cur / 4, y = cur % 4;
        for (int i = 0; i &lt; 4; i++) {
            int nx = x + dir[i][0], ny = y + dir[i][1];
            if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4)
                continue;
            if (blocked[nx][ny])
                continue;
            int next = cell2num(nx, ny);
            if (parent[next] != -1)
                continue;
            parent[next] = cur;
            q.push(next);
        }
    }

    if (parent[to] == -1)
        return vector&lt;int&gt;();

    // get the path

    stack&lt;int&gt; transit;
    while (to != -2) {
        transit.push(to);
        to = parent[to];
    }

    // get the direction of the path
    vector&lt;int&gt; path;
    while (transit.size() &gt; 1) {
        int from = transit.top();
        transit.pop();
        int to = transit.top();

        int xFrom = from / 4, yFrom = from % 4;
        int xTo = to / 4, yTo = to % 4;

        for (int i = 0; i &lt; 4; i++) {
            if (xFrom + dir[i][0] == xTo &amp;&amp; yFrom + dir[i][1] == yTo) {
                path.push_back(i);
                break;
            }
        }
    }
    return path;
}

vector&lt;int&gt; move(Puzzle puzzle, int from, int to) {
    // find a whole path from the start to the end
    vector&lt;int&gt; path = findPath(from, to);
    if (path.empty())
        return vector&lt;int&gt;();

    vector&lt;int&gt; moves;
    // the moves that need to be done, including the empty cell
    int currX = from / 4, currY = from % 4;
    for (int i = 0; i &lt; path.size(); i++) {
        int nextX = currX + dir[path[i]][0], nextY = currY + dir[path[i]][1];
        int zeroPos = getPos(puzzle, 0);
        int zeroX = zeroPos / 4, zeroY = zeroPos % 4;

        if (zeroPos != cell2num(nextX, nextY)) {
            // the empty cell is not next to the number, so the move is not valid
            // move the empty cell to the position next to the number

            // block the current cell
            blocked[currX][currY] = true;

            // find the path from the empty cell to the position next to the number
            vector&lt;int&gt; path2 = findPath(zeroPos, cell2num(nextX, nextY));
            if (path2.empty())
                return vector&lt;int&gt;();

            // move the empty cell
            for (int j = 0; j &lt; path2.size(); j++) {
                int nextZeroX = zeroX + dir[path2[j]][0], nextZeroY = zeroY + dir[path2[j]][1];
                moves.push_back(path2[j]);
                swap(puzzle[zeroX][zeroY], puzzle[nextZeroX][nextZeroY]);
                zeroX = nextZeroX, zeroY = nextZeroY;
            }

            // unblock the current cell
            blocked[currX][currY] = false;
        }

        // moves.push_back(path[i]); this is the move of the number, not the empty cell
        // move push_back opposite (0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2)
        moves.push_back(path[i] ^ 1);

        swap(puzzle[currX][currY], puzzle[nextX][nextY]);
        currX = nextX, currY = nextY;
    }

    return moves;
}

bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to) {
    // do not need to move
    if (from == to)
        return true;

    vector&lt;int&gt; moves = move(puzzle, from, to);
    if (moves.empty())
        return false;

    for (int i = 0; i &lt; moves.size(); i++) {
        ans.push_back(moves[i]);
        int zeroPos = getPos(puzzle, 0);
        int zeroX = zeroPos / 4, zeroY = zeroPos % 4;
        swap(puzzle[zeroX][zeroY], puzzle[zeroX + dir[moves[i]][0]][zeroY + dir[moves[i]][1]]);
    }

    return true;
}

int main() {
    Puzzle puzzle(4, vector&lt;int&gt;(4));
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j];
    }

    if (!isValid(puzzle)) {
        cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl;
        return 0;
    }
    if (!hasSolution(puzzle)) {
        cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl;
        return 0;
    }

    vector&lt;int&gt; ans;
    bool flag = true;

    // step 1: move [1] to pos 0
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 1), 0);
    blocked[0][0] = true;

    // step 2: move [2] to pos 1
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 2), 1);
    blocked[0][1] = true;

    // step 3: move [4] to pos 2
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2);

    // step 4: if [3] is in pos 3 or (7 &amp;&amp; 3 is empty), we have to move it away
    //         -&gt; move [3] to pos 10

    if (getPos(puzzle, 3) == 3 || (getPos(puzzle, 3) == 7 &amp;&amp; getPos(puzzle, 0) == 3)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 10);
        blocked[2][2] = true;
        // move [4] back to pos 2, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2);
        blocked[2][2] = false;
    }
    blocked[0][2] = true;

    // step 5: move [3] to pos 6
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 6);
    blocked[1][2] = true;

    // step 6: move [4] to pos 3
    blocked[0][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 3);
    blocked[0][3] = true;

    // step 7: move [3] to pos 2
    blocked[1][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 2);
    blocked[0][2] = true;

    // now we have [1] [2] [3] [4] in the right place, and they are blocked

    // step 8: move [5] to pos 4
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 5), 4);
    blocked[1][0] = true;

    // step 9: move [6] to pos 5
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 6), 5);
    blocked[1][1] = true;

    // step 10: move [8] to pos 6
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6);

    // step 11: if [7] is in pos 7 or (11 &amp;&amp; 7 is empty), we have to move it away
    //          -&gt; move [7] to pos 14

    if (getPos(puzzle, 7) == 7 || (getPos(puzzle, 7) == 11 &amp;&amp; getPos(puzzle, 0) == 7)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 14);
        blocked[3][2] = true;
        // move [8] back to pos 6, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6);
        blocked[3][2] = false;
    }
    blocked[1][2] = true;

    // step 12: move [7] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 10);
    blocked[2][2] = true;

    // step 13: move [8] to pos 7
    blocked[1][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 7);
    blocked[1][3] = true;

    // step 14: move [7] to pos 6
    blocked[2][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 6);
    blocked[1][2] = true;

    // now we have [5] [6] [7] [8] in the right place, and they are blocked

    // step 15: move [13] to pos 8
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8);

    // step 16: if 9 is in pos 12 or (13 &amp;&amp; 12 is empty), we have to move it away
    //          -&gt; move [9] to pos 10

    if (getPos(puzzle, 9) == 12 || (getPos(puzzle, 9) == 13 &amp;&amp; getPos(puzzle, 0) == 12)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 10);
        blocked[2][2] = true;
        // move [13] back to pos 8, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8);
        blocked[2][2] = false;
    }
    blocked[2][0] = true;

    // step 17: move [9] to pos 9
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 9);
    blocked[2][1] = true;

    // step 18: move [13] to pos 12
    blocked[2][0] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 12);
    blocked[3][0] = true;

    // step 19: move [9] to pos 8
    blocked[2][1] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 8);
    blocked[2][0] = true;

    // now we have [9] [13] in the right place, and they are blocked

    // step 20: move [14] to pos 9
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9);

    // step 21: if [10] is in pos 13 or (14 &amp;&amp; 13 is empty), we have to move it away
    //          -&gt; move [10] to pos 11

    if (getPos(puzzle, 10) == 13 || (getPos(puzzle, 10) == 14 &amp;&amp; getPos(puzzle, 0) == 13)) {
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 11);
        blocked[2][3] = true;
        // move [14] back to pos 9, since we moved it away in the calc() above
        flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9);
        blocked[2][3] = false;
    }
    blocked[2][1] = true;

    // step 22: move [10] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 10);
    blocked[2][2] = true;

    // step 23: move [14] to pos 13
    blocked[2][1] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 13);
    blocked[3][1] = true;

    // step 24: move [10] to pos 9
    blocked[2][2] = false;
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 9);
    blocked[2][1] = true;

    // now we have [10] [14] in the right place, and they are blocked

    // step 25: move [11] to pos 10
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 11), 10);
    blocked[2][2] = true;

    // step 26: move [12] to pos 11
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 12), 11);
    blocked[2][3] = true;

    // step 27: move [15] to pos 14
    flag &amp;= calc(puzzle, ans, getPos(puzzle, 15), 14);
    blocked[3][2] = true;

    // now we have [11] [12] [15] in the right place, and they are blocked

    if (!flag) {
        cout &lt;&lt; &quot;Something went wrong&quot; &lt;&lt; endl;
        return 0;
    }

    // make the answer simpler, removing unnecessary moves
    for (int i = 0; i &lt; ans.size(); i++) {
        if ((ans[i] ^ ans[i + 1]) == 1) {
            ans.erase(ans.begin() + i);
            ans.erase(ans.begin() + i);
            i -= 2;
            // go back 2 steps, to make sure we didn't create another unnecessary move
        }
    }

    // print the answer
    cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; ans.size() &lt;&lt; &quot; moves):&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; ans.size(); i++) {
        cout &lt;&lt; arrows[ans[i]];
        if (i % 5 == 4)
            cout &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>你可能会问：为什么 <code>move()</code> 和 <code>calc()</code> 不能合并在一块儿？<br>
优质答案：<s>我不知道</s>可以，但是我不想改了。<br>
你又会问：为什么你连位运算都改了，却不愿意改这个？<br>
优质答案：去写暑假作业了。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>由 M1 驱动的 MacBook Air 运算。在其他的电脑上，运行时间可能有所不同。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213">https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222">https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>如下图，共 556 份。<br>
<img src="https://oimaster.top/post-images/1688201644902.jpeg" alt="" loading="lazy"> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://oimaster.top/post/29iMUCdw4/" class="post-title gt-a-link">
                    强连通分量与缩点
                </a>
            </div>
        

        
            <span id="/post/-jrYcZ0cc/" class="leancloud_visitors" data-flag-title="用计算机解决 15 数码问题">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">0</i>
            </span>
        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: '275sUQvvEtJ8AhDatydWZcWe-9Nh9j0Va',
		appKey: 'lvyhEM2OvNgQKqruQcnKKsRL',
		avatar: '',
		pageSize: 5,
		recordIp: true,
		placeholder: '说点什么好呢',
		visitor: true,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">これこそが人間の感情の極み。希望よりも熱く、絶望よりも深いモノーー愛、よ</div>
    <div class="social-container">
        
            
                <a href="https://github.com/oimasterkafuu" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="https://twitter.com/oimasterakioi" target="_blank">
                    <i class="fab fa-twitter gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        © 2023 <span class="madoka">oimaster</span>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://oimaster.top/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
