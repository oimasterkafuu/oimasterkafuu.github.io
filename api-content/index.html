{"posts":[{"title":"å½“ä½ çœ‹åˆ°ä¸€é“é¢˜â€¦â€¦","content":"å½“ä½ çœ‹åˆ°äº†ä¸€é“æ—¶é™ 1000ms çš„é¢˜ğŸ¤”â€¦â€¦ ä¸é”™ï¼Œæˆ‘è¦åšè¿™é“é¢˜ï¼ğŸ’ª æœ¬åœ°æµ‹è¯•ä¸€ä¸‹ï¼ æ—¶é—´å°±å·®ä¸€ç‚¹ï¼å·®ä¸€ç‚¹ï¼Œäº¤äº¤çœ‹ï¼ğŸ¤ è¿™æ€ä¹ˆå…¨æŒ‚äº†å•Šâ€¦â€¦ä¸å¯èƒ½ï¼ğŸ˜± æ—¶é™ 1000ms æ”¹æˆ 2000msï¼Œçœ‹ä½ è¿‡ä¸è¿‡ã€‚ğŸ¤” è¿‡äº†ï¼Œèµ¶ç´§æ”¹å›æ¥ï¼ğŸ˜… æ”¹å›æ¥äº†ï¼Œè¿™æ ·åˆä¸ä¼šæœ‰äººè¿‡äº†ï¼ å¥½è€¶ï¼ğŸ‰ è‚¯å®šä¸æ˜¯æˆ‘çš„ä»£ç é—®é¢˜ï¼ ","link":"https://oimaster.top/post/VDodg3tO5/"},{"title":"æ‰“ç®—å†™å‡æœŸæ—¥æŠ¥ï¼","content":"å¼€åˆ›ä¸€ä¸ªæ—¥æŠ¥ï¼Œæƒ³é€šè¿‡è¿™ç§æ–¹å¼ç£ä¿ƒè‡ªå·±å¹²ç‚¹æ­£äº‹ã€‚è¿™ä¸ªå‡æœŸæ— ç‰¹æ®Šæƒ…å†µæ¯å¤©éƒ½å†™ã€‚æœ‰ç‰¹æ®Šæƒ…å†µå°†ä¼šåœ¨ä¸‹ä¸€æ¬¡å†™çš„æ—¶å€™è¯´æ˜ã€‚ æ¯ä¸€ä¸ªæ—¥æŠ¥ä¼šåŒ…æ‹¬ä»¥ä¸‹çš„å†…å®¹ã€‚ å¹²ä»€ä¹ˆç³»åˆ— ä»Šå¤©è¦å¹²ä»€ä¹ˆ ä»Šå¤©å¹²äº†ä»€ä¹ˆ ä»Šå¤©æ²¡å¹²ä»€ä¹ˆ æ˜å¤©è¦å¹²ä»€ä¹ˆ æƒ…ç»ªç³»åˆ— ä»Šå¤©å¿ƒæƒ…æ€ä¹ˆæ · ä»Šå¤©ä¸ºä»€ä¹ˆè¿™æ · å…¶ä»– ç‰¹æ®Šåœ°ï¼Œå¦‚æœå½“æ—¥å‘å¸ƒäº†å…¶ä»–æ–‡ç« ï¼Œæ—¥æŠ¥å¯ä»¥ä¸å†™ã€‚ å¸Œæœ›å¤§å®¶ç£ä¿ƒæˆ‘å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚å¯¹äºæ‰€æœ‰çš„æ—¥æŠ¥ï¼Œè¯·ä» #æ—¥æŠ¥ æ ‡ç­¾æˆ–é¡¶æ è¿›å…¥ï¼Œä¸æ˜¾ç¤ºåœ¨ä¸»é¡µåˆ—è¡¨ä¸­æˆ–å½’æ¡£é¡µé¢ã€‚ å¦‚æœæ‚¨è§‰å¾—æˆ‘åšå¾—ä¸å¥½ï¼Œè¯·ä»æ—¥æŠ¥é¡µé¢åº•éƒ¨çš„è¯„è®ºåŒºç‚¸æˆ‘ä¸€ä¸‹ã€‚ æ—¥æŠ¥ä» 2023-07-05 å¼€å§‹å†™ã€‚æ—¥æŠ¥åœ¨åˆ—è¡¨ä¸­æ˜¾ç¤ºæ—¶å³ä¾§æ²¡æœ‰é…å›¾ã€‚ ","link":"https://oimaster.top/post/gb9I1Pn8V/"},{"title":"ç”¨è®¡ç®—æœºè§£å†³ 15 æ•°ç é—®é¢˜","content":"æœŸæœ«è€ƒè¯•é˜¶æ®µï¼Œæœ‰ä¸å°‘å‹åŠ›ã€‚è¿™æ—¶å€™ï¼Œçœ‹åˆ°äº†ä¸€ä¸ªå°ç©å…·ã€‚ æˆ‘è®¤ä¸ºè¿™æœ‰åŠ©äºæˆ‘æ”¾æ¾ã€‚äºæ˜¯ï¼Œæˆ‘å°è¯•è§£å†³å®ƒã€‚ç„¶è€Œï¼Œè¿™èŠ±äº†æˆ‘ 5 åˆ†é’Ÿå·¦å³ã€‚ æˆ‘æ„Ÿåˆ°å¾ˆä¸æœæ°”ã€‚æˆ‘æ‰“ç®—å¾æœå®ƒã€‚ å®½ï¼ˆå¹¿ï¼‰åº¦ä¼˜å…ˆæœç´¢ æˆ‘æ‰“ç®—ä½¿ç”¨ç”µè„‘æå‡è§£é¢˜é€Ÿåº¦ã€‚åˆšå¼€å§‹ï¼Œæˆ‘è®¤ä¸ºè¿™ä¸éš¾ï¼Œåº”è¯¥åœ¨äºŒåå‡ æ­¥å†…å®Œæˆã€‚ æ­¤æ—¶ï¼Œä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¾ç„¶ä¸é€‚åˆï¼Œå› ä¸ºåœ¨ä¸€æ­¥é”™è¯¯ä¸‹å¾ˆå¯èƒ½åˆ†å‰å‡ºå¾ˆå¤šç§å¯èƒ½ã€‚äºæ˜¯æˆ‘æ‰“ç®—ç”¨å®½æœã€‚ å› ä¸ºæ‰å®Œæˆä¸€ä¸ª Vue é¡¹ç›®ï¼Œæ‰€ä»¥æˆ‘é¡ºæ‰‹å†™äº†ä¸€ç‚¹ JS ä»£ç ï¼ˆç°åœ¨è¢«æˆ‘åˆ äº†ï¼Œå¾ˆå¯æƒœä½ ä»¬çœ‹ä¸åˆ°ï¼‰ã€‚å½“æˆ‘æŒ‰ä¸‹å›è½¦åï¼Œæˆ‘çš„ Node.js ç¬é—´å¡æ­»äº†ã€‚ æˆ‘ä»¥ä¸ºå¯èƒ½æ˜¯ Javascript æ‰§è¡Œé€Ÿåº¦å¤ªæ…¢ï¼Œå°±é‡å†™äº†ä¸€ä»½ C++ ä»£ç ã€‚ä»ç„¶å¾ˆæ…¢ã€‚å·²ç»åˆ°äº†æ·±å¤œï¼Œæˆ‘ä¾¿å›å»å¤ä¹ äº†ã€‚ A* è¿™äº‹æƒ…æœ¬æ¥ç»“æŸäº†çš„ï¼Œç„¶è€Œæˆ‘åœ¨æ™šä¸Šç©è€æ—¶çœ‹åˆ°äº†ä¸€ä¸ªç½‘ç«™ã€‚ å®ƒæä¾›çš„æ ·ä¾‹æ˜¯ 5,1,4,7,2,11,3,8,9,6,14,15,13,10,0,12ï¼Œä¸€å…±æœ‰ 19 æ­¥ï¼Œä½†æ˜¯å®ƒç¬é—´å°±è§£å†³äº†ã€‚ æˆ‘æŸ¥çœ‹äº†å®ƒçš„æºä»£ç ã€‚å®ƒä½¿ç”¨äº†å¯å‘å¼æœç´¢ã€‚æˆ‘ä¸èƒ½è½åã€‚ å› ä¸º C++ é‡Œé¢æä¾›äº† priority_queueï¼Œå†åŠ ä¸Š Javascript åœ¨å¤æ‚è®¡ç®—æ—¶å¤ªæ…¢äº†ï¼Œæ‰€ä»¥æˆ‘ä¼˜å…ˆä½¿ç”¨ C++ã€‚ æ€è·¯æ˜¯è¿™æ ·çš„ï¼š å¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéå†æ‰€æœ‰çš„æ•°ç ï¼› å¯¹äºæ¯ä¸€ä¸ªæ•°ç ï¼Œè®¡ç®—æ•°ç åº”è¯¥åœ¨çš„ä½ç½®ï¼› æ¥ä¸‹æ¥ï¼Œè®¡ç®—å½“å‰ä½ç½®ä¸æ­£ç¡®ä½ç½®çš„è·ç¦»ï¼Œå¹¶ç´¯åŠ ã€‚ è¿™æ ·ï¼Œå¾—åˆ°äº†èŠ‚ç‚¹çš„åˆ†æ•°ã€‚æ®æ­¤è¿›è¡Œ A*ã€‚ å¦å¤–ï¼Œå› ä¸ºä½¿ç”¨ä¸€æ•´ä¸ªæ•°ç»„æœç´¢å¤ªä¸æ–¹ä¾¿ï¼Œæˆ‘ä½¿ç”¨äº† getHash() å‡½æ•°è¿›è¡Œå“ˆå¸Œã€‚å®é™…ä¸Šï¼Œç”±äºæˆ‘ç”¨çš„æ˜¯ unsigned long long ç±»å‹ï¼Œæ‰€ä»¥ä¸éœ€è¦å–æ¨¡ï¼Œä¹Ÿä¸ä¼šæœ‰é‡å¤çš„æ•°å€¼ã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ctime&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;map&gt; using namespace std; bool isValid(vector&lt;vector&lt;int&gt;&gt; puzzle) { // verify size if (puzzle.size() != 4) return false; for (int i = 0; i &lt; 4; i++) { if (puzzle[i].size() != 4) return false; } bool exist[16] = { false }; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (puzzle[i][j] &lt; 0 || puzzle[i][j] &gt; 15) return false; if (exist[puzzle[i][j]]) return false; exist[puzzle[i][j]] = true; } } return true; } unsigned long long getHash(vector&lt;vector&lt;int&gt;&gt; puzzle) { unsigned long long hash = 0; for (int i = 0; i &lt; 16; i++) { hash = hash * 16 + puzzle[i / 4][i % 4]; } return hash; } int getScore(vector&lt;vector&lt;int&gt;&gt; puzzle) { int score = 0; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (puzzle[i][j] == 0) continue; score += abs(i - (puzzle[i][j] - 1) / 4) + abs(j - (puzzle[i][j] - 1) % 4); } } return score; } int main() { vector&lt;vector&lt;int&gt;&gt; puzzle(4, vector&lt;int&gt;(4)); for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j]; } int time = clock(); if (!isValid(puzzle)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl; return 0; } // A* search priority_queue&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;, vector&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;, greater&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt; pq; set&lt;unsigned long long&gt; visited; pq.push(make_pair(getScore(puzzle), puzzle)); visited.insert(getHash(puzzle)); map&lt;unsigned long long, unsigned long long&gt; parent; map&lt;unsigned long long, char&gt; direction; map&lt;unsigned long long, int&gt; depth; map&lt;unsigned long long, int&gt; cost; while (!pq.empty()) { vector&lt;vector&lt;int&gt;&gt; cur = pq.top().second; pq.pop(); if (getScore(cur) == 0) { // print solution vector&lt;unsigned long long&gt; path; unsigned long long curHash = getHash(cur); while (curHash != getHash(puzzle)) { path.push_back(curHash); curHash = parent[curHash]; } reverse(path.begin(), path.end()); cout &lt;&lt; &quot;Solution:&quot; &lt;&lt; endl; for (int i = 0; i &lt; path.size(); i++) { cout &lt;&lt; direction[path[i]]; if (i % 5 == 4) cout &lt;&lt; ' '; } cout &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1.0 / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } int curDepth = depth[getHash(cur)]; int curCost = cost[getHash(cur)]; int zeroX = -1, zeroY = -1; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (cur[i][j] == 0) { zeroX = i; zeroY = j; break; } } } // move up if (zeroX &gt; 0) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX - 1][zeroY]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'U'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move down if (zeroX &lt; 3) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX + 1][zeroY]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'D'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move left if (zeroY &gt; 0) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX][zeroY - 1]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'L'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move right if (zeroY &lt; 3) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX][zeroY + 1]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'R'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } } cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl; return 0; } è¿è¡Œèµ·æ¥å¤§æ¦‚æ˜¯è¿™æ ·çš„[1]ï¼š oimaster@kafuu 23-07-01 16:02:33 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b oimaster@kafuu 23-07-01 16:02:45 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 9 5 1 4 3 7 2 8 6 0 10 11 13 14 15 12 Solution: ULURR DLDLU URRDL DRRD Time: 1.758ms ç„¶åæˆ‘å°±å‘äº†æ¡ç©ºé—´ã€‚ å¿«ä¸€ç‚¹çš„ A* å½“æˆ‘å‘å‡ºå»åï¼Œæˆ‘æ„è¯†åˆ°è‡ªå·±çš„è¡Œä¸ºååˆ†æ„šè ¢ã€‚A* ç®—æ³•å¾ˆå¤šäººéƒ½ä¼šã€‚ç„¶è€Œï¼Œå› ä¸ºæˆ‘ä½¿ç”¨äº†å¤§é‡çš„ STLï¼Œä½†æ˜¯ç¼–è¯‘æ—¶è¿ -O2 éƒ½æ²¡æœ‰åŠ ä¸Šï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“è¢«è¶…è¶Šã€‚ å“å¾—æˆ‘èµ¶ç´§åŠ ä¸Šäº† -Ofastã€‚å¯ä»¥å‘ç°ç¡®å®å¿«äº†ä¸å°‘ã€‚ oimaster@kafuu 23-07-01 16:24:10 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b oimaster@kafuu 23-07-01 16:24:16 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 3 5 7 4 6 9 2 12 0 13 11 14 10 1 8 15 Solution: DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD Time: 1438.26ms oimaster@kafuu 23-07-01 16:24:19 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b -Ofast oimaster@kafuu 23-07-01 16:24:29 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 3 5 7 4 6 9 2 12 0 13 11 14 10 1 8 15 Solution: DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD Time: 265.271ms oimaster@kafuu 23-07-01 16:24:32 ~/Documents/code/puzzle &gt;&gt;&gt; ç«‹åˆ»å‘äº†æ¡ç©ºé—´åˆ·æ–°æˆ‘çš„è®°å½•ã€‚ä¸¤æ¡ç©ºé—´é—´éš”ä¸åˆ°ååˆ†é’Ÿã€‚æ˜¾ç„¶æ˜¯åŠ äº†ç‚¹ç¼–è¯‘ä¼˜åŒ–é€‰é¡¹ï¼Œæ”¹ä¸äº†å¤šå°‘ä»£ç ã€‚ ä½è¿ç®—ç‰ˆ A* å¦‚ä¸Šé¢æ‰€è¯´ï¼Œç¬¬äºŒå¤©ä¸‹åˆï¼Œæˆ‘å°±å»å†™äº†ä½è¿ç®—ã€‚è¿™ä¸ªæ¯”è¾ƒéº»çƒ¦ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ€è€ƒå¦‚ä½•è¡¨ç¤ºä¸€ä¸ªæ£‹ç›˜ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ å°†æ‰€æœ‰çš„ç©ºæ ¼æ¢æˆ 000ï¼Œé‚£ä¹ˆå¯ä»¥å‘ç°æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯ [0,16)\\left[0, 16\\right)[0,16) ä¸­çš„æ•´æ•°ï¼Œå¾ˆæ–¹ä¾¿ä½è¿ç®—ã€‚ æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³çš„é¡ºåºï¼Œå°±å¯ä»¥æŠŠä¸Šé¢çš„æ£‹ç›˜è½¬æ¢æˆåå…­è¿›åˆ¶ï¼š (123456789abcdef0)16=(1311768467463790320)10\\left(123456789abcdef0\\right)_{16} = \\left(1311768467463790320\\right)_{10} (123456789abcdef0)16â€‹=(1311768467463790320)10â€‹ å…¶ä¸­ï¼Œæ¯ä¸€ä¸ªæ•°ä½ä»£è¡¨ç€ä¸€ä¸ªä½ç½®ä¸Šçš„æ•°å­—ã€‚ å¯¹äºè¿™ä¸ªå¤§æ•°å­—ï¼Œæˆ‘ä»¬æ€è€ƒå¦‚ä½•å­˜å‚¨å®ƒã€‚unsigned long long å¯ä»¥å—ï¼Ÿå®ƒçš„èŒƒå›´æ˜¯ [0,264âˆ’1]\\left[0, 2^{64}-1\\right][0,264âˆ’1]ï¼Œä¹Ÿå°±æ˜¯ä¸€ç›´åˆ° 184467440737095516151844674407370955161518446744073709551615ã€‚è¿œè¿œå¤§äº 131176846746379032013117684674637903201311768467463790320ï¼Œæ”¾å¿ƒå§ã€‚ æ‰€ä»¥å°±å¯ä»¥å†™å‡ºè¾“å…¥ï¼š #define puzzle unsigned long long puzzle p = 0; for (int i = 0; i &lt; 16; i++) { int x; cin &gt;&gt; x; p = (p &lt;&lt; 4) + x; } æ¥ä¸‹æ¥ï¼Œå°±æ˜¯å¤„ç†ç§»åŠ¨ã€‚è¿™å°†ä¼šæ˜¯ä¸€ä¸ªå¤§å·¥ç¨‹ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ‰¾åˆ° 000 æ‰€åœ¨çš„æ•°ä½ã€‚ int zero = 0; while (((x &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++; å¦‚æœæˆ‘ä»¬è¦å‘ä¸Šæ–¹ç§»åŠ¨ï¼Œæ¨ªç€çœ‹ï¼Œæˆ‘ä»¬å°±éœ€è¦å‘å‰ 444 ä¸ªæ•°ä½ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬è¦æŠŠ 000 ä¸Šç§»ï¼š 123456789abcdef0 ^ 123456789ab0defc ^ å…¶æœ¬è´¨æ˜¯ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ 1 2 3 4 5 6 7 8 9 10 11 _ 13 14 15 12 äºæ˜¯ï¼Œä½ å°±å¯ä»¥å†™å‡ºä»£ç ï¼Œè·å– 000 ä¸Šæ–¹çš„æ•°å­—æ˜¯å¤šå°‘ï¼š int top = zero + 4; int dig = (x &gt;&gt; (top &lt;&lt; 2)) &amp; 15; å¥‡æ€ªï¼Œç¬¬ä¸€è¡Œä¸ºä»€ä¹ˆæ˜¯ zero + 4 è€Œä¸æ˜¯ zero - 4 å‘¢ï¼Ÿä¸çŸ¥é“ä½ ä»¬æœ‰æ²¡æœ‰å‘ç°ï¼Œæˆ‘ä»¬çš„æ•°ä½æ˜¯é¢ å€’çš„ã€‚æ‰€ä»¥æ­£ç¡®çš„ç§»åŠ¨å…¶å®æ˜¯ç¬¬ 000 ä½åˆ°ç¬¬ 444 ä½ã€‚ï¼š 123456789abcdef0 ^ 0 123456789ab0defc ^ 4 ä¸è¿‡åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯è·å–åˆ°äº† digâ†12dig \\leftarrow 12digâ†12ã€‚æˆ‘ä»¬è¿˜éœ€è¦æŠŠè¿™ä¸ªæ•°å­—ç§»åŠ¨åˆ° 000 åŸæ¥æ‰€åœ¨çš„ä½ç½®ã€‚ x |= (unsigned long long)dig &lt;&lt; (zero &lt;&lt; 2); è¿™è¡Œä»£ç ä½¿ç”¨ã€Œæˆ–ã€è¿ç®—ï¼Œå› ä¸º 000 çš„äºŒè¿›åˆ¶å…¨éƒ¨ä¸º 000ï¼Œæ‰€ä»¥æˆ–è¿ç®—æœ¬è´¨ä¸Šå°±æ˜¯æ‹·è´ã€‚ äºæ­¤åŒæ—¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æŠŠåŸæ¥ä¸Šæ–¹çš„æ ¼å­æ¸…é›¶ã€‚æˆ‘ä»¬éœ€è¦ã€Œä¸ã€è¿ç®—ã€‚è¿ç®—æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä¿è¯ä¸Šæ–¹çš„æ ¼å­å¯¹åº”ã€Œ0ã€ä»è€Œåˆ é™¤ï¼Œè€Œå…¶ä»–çš„ä½ç½®ä¸å˜ã€‚äºæ˜¯è‡ªç„¶åˆä¼šæƒ³åˆ°å°† (15)10=(1111)2\\left(15\\right)_{10} = \\left(1111\\right)_2(15)10â€‹=(1111)2â€‹ ç§»åŠ¨åˆ°é‚£ä¸€ä½ï¼ŒåŒæ—¶å–åï¼Œè®©å…¶ä»–ä½å˜ä¸º 111â€”â€”ä¸å¹²æ‰°ã€‚ äºæ˜¯å†™å‡ºï¼š x &amp;= ~((unsigned long long)15 &lt;&lt; (top &lt;&lt; 2)); æ•´ç†ä¸€ä¸‹ä¸Šæ–¹æ‰€æœ‰çš„ä½è¿ç®—ï¼Œå‹åˆ°ä¸€è¡Œé‡Œï¼š x = (x | ((x &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2)) &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2)); æå®šï¼å…¶ä»–æ–¹å‘åŒç†ï¼Œäºæ˜¯æˆ‘ä»¬å°±å¯ä»¥å†™å‡ºæœç´¢æ—¶çš„ä»£ç ã€‚ åˆ¤æ–­æ— è§£ ä¸ºäº†æ–¹ä¾¿æˆ‘çš„æ—¶é—´æµ‹é‡ï¼Œé˜²æ­¢æ²¡å¿…è¦çš„æµªè´¹ï¼Œæˆ‘æœ‰å¿…è¦å†™å‡ºæ¥åˆ¤æ–­æ— è§£çš„ä»£ç ã€‚ è®©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹æœ‰è§£çš„å‡ ç§æƒ…å†µã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 _ 15 1 2 3 4 5 6 7 8 9 10 11 _ 13 14 15 12 ä¸ºäº†æ–¹ä¾¿å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠäºŒç»´è½¬ä¸ºä¸€ç»´ï¼Œå’Œä¹‹å‰ä¸€æ ·ï¼Œä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³ã€‚ [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0][1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15][1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0][1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15][1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12] ä»æ•°åˆ—ä¸­åˆ å» 000ï¼Œå¾—åˆ°äº†ï¼š [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,13,14,15,12] ä½ ä¼šå‘ç°ï¼Œç¬¬ä¸€è¡Œå’Œç¬¬äºŒè¡Œæ²¡æœ‰å˜åŒ–ã€‚ç¬¬ä¸‰è¡Œç›¸å¯¹ä¸¤è€…æ¥è¯´ï¼Œ121212 ç§»åŠ¨åˆ°äº† [13,14,15]\\left[13, 14, 15\\right][13,14,15] çš„åæ–¹ï¼Œåˆ›é€ äº† 333 ä¸ªé€†åºå¯¹ã€‚ è®©æˆ‘ä»¬å†æŠŠç©ºæ ¼å¾€ä¸Šç§»åŠ¨ä¸€ä¸‹ã€‚ 1 2 3 4 5 6 7 _ 9 10 11 8 13 14 15 12 [1,2,3,4,5,6,7,9,10,11,8,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 8, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,9,10,11,8,13,14,15,12] æ³¨æ„åˆ° 888 å‘åç§»åŠ¨äº† 333 æ ¼ï¼Œåˆ›é€ äº† 333 ä¸ªé€†åºå¯¹ï¼Œæ­¤æ—¶å…±æœ‰ 666 ä¸ªé€†åºå¯¹ã€‚ ä»”ç»†è§‚å¯Ÿï¼Œä¼šå‘ç° 000 çš„åæ ‡ä¸é€†åºå¯¹çš„å¥‡å¶æ€§æœ‰å…³ç³»ã€‚æ¯å½“ 000 å‘ä¸Šç§»åŠ¨å¥‡æ•°è¡Œï¼ˆæ‰€åœ¨åæ ‡ä¹Ÿä¸ºå¥‡æ•°è¡Œï¼‰ï¼Œé€†åºå¯¹çš„æ•°é‡ä¸ºå¥‡æ•°ã€‚åä¹‹ï¼Œåœ¨å¶æ•°è¡Œæ—¶ï¼Œé€†åºå¯¹çš„æ•°é‡ä¸ºå¶æ•°ã€‚ å¯¹äºå·¦å³ç§»åŠ¨ï¼Œä¸å½±å“åºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¿…è€ƒè™‘ã€‚ å’Œä½è¿ç®—å‘¨æ—‹åŠä¸ªå°æ—¶å°±å¯ä»¥å†™å‡ºä¸‹é¢çš„ä»£ç ï¼š bool hasSolution(puzzle p) { int cnt = 0, zeroX = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) { zeroX = i &gt;&gt; 2; continue; } for (int j = 0; j &lt; i; j++) { int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15; if (y == 0) continue; if (y &lt; x) cnt++; } } return ((cnt + zeroX) &amp; 1) == 0; } æœ€åå†™å®Œæ•´ä»£ç æ—¶å‘ç°ä¹‹å‰çš„ cost æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼Œå°±åˆ æ‰äº†ã€‚å¦å¤–ï¼Œä¸ºäº†åŠ å¿«é€Ÿåº¦ï¼Œæˆ‘æ”¹æˆäº† unordered_map å’Œ unordered_setã€‚ #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;unordered_set&gt; #include &lt;unordered_map&gt; using namespace std; #define puzzle unsigned long long inline bool isValid(puzzle p) { unsigned exist = 0; for (int i = 0; i &lt; 16; i++) { int x = p &amp; 15; if (x &lt; 0 || x &gt; 15) return false; if (exist &amp; (1llu &lt;&lt; x)) return false; exist |= (1llu &lt;&lt; x); p &gt;&gt;= 4; } return true; } unsigned getScore(puzzle p) { unsigned score = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) continue; score += abs((i &gt;&gt; 2) - ((x - 1) &gt;&gt; 2)) + abs((i &amp; 3) - ((x - 1) &amp; 3)); } return score; } bool hasSolution(puzzle p) { int cnt = 0, zeroX = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) { zeroX = i &gt;&gt; 2; continue; } for (int j = 0; j &lt; i; j++) { int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15; if (y == 0) continue; if (y &lt; x) cnt++; } } return ((cnt + zeroX) &amp; 1) == 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); puzzle p = 0; for (int i = 0; i &lt; 16; i++) { int x; cin &gt;&gt; x; p = (p &lt;&lt; 4) + x; } int time = clock(); if (!isValid(p)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } if (!hasSolution(p)) { cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } priority_queue&lt;pair&lt;unsigned, puzzle&gt;, vector&lt;pair&lt;unsigned, puzzle&gt;&gt;, greater&lt;pair&lt;unsigned, puzzle&gt;&gt;&gt; pq; unordered_map&lt;puzzle, puzzle&gt; parent; unordered_map&lt;puzzle, char&gt; direction; unordered_map&lt;puzzle, unsigned&gt; depth; pq.push(make_pair(0, p)); depth[p] = 1; while (!pq.empty()) { puzzle curr = pq.top().second; pq.pop(); if (curr == 0x123456789abcdef0llu) { stack&lt;char&gt; path; while (curr != p) { path.push(direction[curr]); curr = parent[curr]; } cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; path.size() &lt;&lt; &quot; steps):&quot; &lt;&lt; endl; int cnt = 0; while (!path.empty()) { cout &lt;&lt; path.top() &lt;&lt; (((++cnt) % 5 == 0) ? &quot; &quot; : &quot;&quot;); path.pop(); } cout &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } unsigned currDepth = depth[curr]; int zero = 0; while (((curr &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++; if (zero &lt; 12) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'D'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if (zero &gt; 3) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 4) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero - 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'U'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if ((zero &amp; 3) != 3) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 1) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero + 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'R'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if ((zero &amp; 3) != 0) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 1) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero - 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'L'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } } cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } æˆ‘åˆæä¾›äº†ä¸€ä»½æé«˜ç»„çš„é˜…è¯»ç¨‹åºä»£ç ã€‚è€ƒå¯Ÿé‡ç‚¹ï¼šä½è¿ç®—ï¼›éš¾åº¦â˜…â˜…â˜…â˜…â˜…ã€‚ å®ƒè¿è¡Œèµ·æ¥ï¼Œæ›´å¿«äº†ã€‚çœ‹åˆ°å®ƒè¿è¡Œèµ·æ¥ï¼Œæˆ‘æ›´å¿«ä¹ã€‚ä½ æ— æ³•æƒ³è±¡è¿™ä¸œè¥¿æˆ‘è°ƒè¯•äº†å¤šä¹…ã€‚ ä½è¿ç®—ç¡®å®æå‡äº†ä¸å°‘ã€‚ æ›´å¿«çš„æ–¹æ³• è‡³æ­¤ï¼Œæœç´¢æˆ‘ä»¬åŸºæœ¬åˆ°å¤´äº†ã€‚ä½†æ˜¯åœ¨ä¸€äº›å¤æ‚çš„é¢˜ç›®ä¸Šï¼Œä»ç„¶è¦èŠ±å‡ åˆ†é’Ÿæ‰èƒ½ç®—å‡ºã€‚ æˆ‘ä»¬æ˜¯æƒ³è¦ä»€ä¹ˆï¼Ÿæ˜¯è¦æœ€ä¼˜è§£å—ï¼Ÿé‚£ä¹ˆæœç´¢å½“ç„¶å¯ä»¥ã€‚ ä½†æˆ‘çš„ç›®æ ‡ä¸æ˜¯è¿™ä¸ªã€‚æˆ‘çš„ç›®æ ‡æ˜¯åœ¨åšä»»ä½•é¢˜ç›®çš„æ—¶å€™éƒ½å¿«é€Ÿè§£å†³ï¼Œä½†æ˜¯æ­¥æ•°æ²¡æœ‰å¤ªå¤§è¦æ±‚ã€‚ wikiHowï¼Œè¯¥ä½ å‡ºåœºäº†\bï¼šhttps://www.wikihow.com/Solve-a-15-Puzzle è¯·è¯»è€…å…ˆè‡ªè¡Œé˜…è¯»ä¸Šæ–¹æ–‡ç« ã€‚ ä¸€åˆ‡éƒ½å¾ˆè½»æ¾ï¼Œé™¤äº†å‡ ä¸ªé—®é¢˜ï¼Œéœ€è¦æˆ‘ä»¬ç»†åŒ–ã€‚ äººç±»å¾ˆå®¹æ˜“ç§»åŠ¨ï¼Œé‚£ä¹ˆè®¡ç®—æœºæ€ä¹ˆåŠï¼Ÿå¦‚ä½•ä»æœºæ¢°çš„è§’åº¦çœ‹å¾…ã€Œç§»åŠ¨ã€çš„è¿‡ç¨‹ï¼Ÿ æ–‡ä¸­ 3.2 è¯´ï¼šã€ŒPlace 9 on the right side of 13. Move 13 temporarily if you have to.ã€[2]ä»€ä¹ˆæ—¶å€™å«åšã€Œif you have to.ã€ï¼Ÿæˆ‘åˆè¯¥å¦‚ä½•ç§»åŠ¨ï¼Ÿ æœ€åä¸€æ­¥ã€ŒIf they don't go to their original places, do method 3 again by mixing only the last two rows.ã€[3]æœ‰ä½•æ„ä¹‰ï¼Ÿ ç„¶åï¼Œæˆ‘ä»¬æ¥è¿›è¡Œè§£å†³ã€‚ é—®é¢˜ 1 å°†ä¸€ä¸ªæ•°ç å¾€ä¸Šç§»ï¼Œæœ¬è´¨ä¸Šæ˜¯å°†ç©ºæ ¼ç§»åŠ¨åˆ°å…¶ä¸Šæ–¹ï¼Œç„¶åå†å°†ç©ºæ ¼ç§»åŠ¨åˆ°åŸæ•°ç çš„ä½ç½®ã€‚è¿™æ˜¯å› ä¸ºæ¯æ¬¡ç§»åŠ¨ç©ºæ ¼æœ¬è´¨ä¸Šæ˜¯ä¸ç›¸é‚»çš„æ•°ç äº¤æ¢ä½ç½®ã€‚ é—®é¢˜ 2 é€šè¿‡ç©å®ä½“çš„ 15 æ•°ç ï¼Œæˆ‘å‘ç°æœ‰ 2 ç§æƒ…å†µéœ€è¦ç§»åŠ¨ã€Œ13ã€ã€‚åˆ†åˆ«æ˜¯ï¼ˆ? ä»£è¡¨ä»»æ„æ•°å­—ï¼ŒåŒ…æ‹¬ç©ºæ ¼ï¼›_ ä»£è¡¨ç©ºæ ¼ï¼Œæ­¤æ—¶ ? ä¸åŒ…æ‹¬ç©ºæ ¼ï¼‰ï¼š 1 2 3 4 5 6 7 8 13 ? ? ? 9 ? ? ? 1 2 3 4 5 6 7 8 13 ? ? ? _ 9 ? ? è¿™ä¸¤ç§æƒ…å†µå¾ˆå®¹æ˜“äº’ç›¸è½¬æ¢ã€‚å¯ä»¥è¿™æ ·ï¼š å°†å³ä¾§ 6 ä¸ª ? ä¸­çš„ç©ºæ ¼ç§»åŠ¨åˆ° 999 çš„å³ä¾§ï¼Œå¾—åˆ°ï¼š1 2 3 4 5 6 7 8 13 ? ? ? 9 _ ? ? ç§»åŠ¨ã€Œ9ã€ã€‚ æ­¤æ—¶ï¼Œå› ä¸ºæ¯å½“å°è¯•å°†ã€Œ9ã€æ”¹å˜ä½ç½®æ—¶å¿…å°†å µæ­»ï¼Œæ‰€ä»¥éœ€è¦ã€Œ13ã€ç§»åŠ¨ã€‚ç§»åŠ¨çš„æ–¹æ³•ï¼Œæˆ‘æ€»ç»“å‡ºæ¥ä»¥ä¸‹çš„ç»“æœï¼š å…è®¸æ”¹åŠ¨ã€Œ13ã€çš„ä½ç½®ï¼Œå°†ã€Œ9ã€ç§»åŠ¨åˆ°ç¬¬ä¸‰è¡Œã€ç¬¬ä¸‰åˆ—ï¼ˆå³åŸæ¥ã€Œ11ã€æ‰€åœ¨çš„ä½ç½®ï¼‰ã€‚ åœ¨å°†ã€Œ9ã€ä¿æŒä¸åŠ¨çš„æƒ…å†µä¸‹ï¼Œåˆ©ç”¨å·¦ä¸‹è§’ 2Ã—22 \\times 22Ã—2 çš„ç©ºé—´å°†ã€Œ13ã€å½’å›åŸä½ã€‚ ç§»åŠ¨ã€Œ9ã€åˆ°ç¬¬ä¸‰è¡Œï¼Œç¬¬äºŒåˆ—ï¼Œå®Œæˆæ­¤æ­¥éª¤ã€‚ å› ä¸ºç¬¬ä¸‰è¡Œã€ç¬¬ä¸‰åˆ—å¹¶ä¸åœ¨å·¦ä¸‹è§’ 2Ã—22 \\times 22Ã—2 çš„ç©ºé—´å†…ï¼Œæ‰€ä»¥ç°åœ¨ç§»åŠ¨ã€Œ13ã€çš„æ—¶å€™å¿…å°†ä¸ä¼šå¹²æ‰°ã€Œ9ã€ã€‚ é—®é¢˜ 3 ä¸€å¥è¯ï¼šå®è·µè¡¨æ˜ï¼Œæ²¡å¿…è¦ã€‚ ä»£ç å®ç° é¦–å…ˆï¼Œæˆ‘å¯¹äºæ¯ä¸€ä¸ªæ ¼å­éƒ½ç»™äºˆç¼–å·ã€‚ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 æ¥ä¸‹æ¥ï¼Œæˆ‘å¯¹äºå½“å‰é‡è¦çš„æ ¼å­å’Œå·²ç»è§£å†³çš„æ ¼å­ï¼Œèµ‹äºˆ blocked å±æ€§ã€‚ åœ¨ vector&lt;int&gt; findPath(int from, int to); ä¸­ï¼Œç¨‹åºä¼šé€šè¿‡å®½åº¦ä¼˜å…ˆæœç´¢ï¼Œç»™å‡ºä¸€æ¡ fromâ†’tofrom \\rightarrow tofromâ†’to çš„è·¯å¾„ï¼Œä¸ç»è¿‡ blocked æŒ‡å®šçš„æ ¼å­ã€‚ åœ¨ vector&lt;int&gt; move(Puzzle puzzle, int from, int to); ä¸­ï¼Œç¨‹åºä¼šå¤šæ¬¡è°ƒç”¨ findpath()ï¼Œå°†åœ¨ from ä½ç½®ä¸Šçš„æ•°ç ç§»åŠ¨åˆ° toï¼Œå³åŒ…æ‹¬äº†ç©ºæ ¼å­çš„è®¡ç®—ã€‚ åœ¨ bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to); ä¸­ï¼Œç¨‹åºä¼šè®°å½•ç­”æ¡ˆï¼Œå¹¶è¿”å›æ˜¯å¦æˆåŠŸã€‚ æ›´å¤šçš„å†…å®¹ï¼Œè¯·å‚ç…§æ³¨é‡Šã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; typedef vector&lt;vector&lt;int&gt;&gt; Puzzle; #define cell2num(x, y) ((x)*4 + (y)) // check if the puzzle is valid bool isValid(Puzzle puzzle) { vector&lt;bool&gt; exist(16, false); for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] &lt; 0 || puzzle[i / 4][i % 4] &gt; 15) return false; if (exist[puzzle[i / 4][i % 4]]) return false; exist[puzzle[i / 4][i % 4]] = true; } return true; } // get if the puzzle has solution bool hasSolution(Puzzle puzzle) { int inversions = 0; int zeroRow = 0; for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] == 0) { zeroRow = i / 4; continue; } for (int j = 0; j &lt; i; j++) { if (puzzle[j / 4][j % 4] == 0) continue; if (puzzle[j / 4][j % 4] &gt; puzzle[i / 4][i % 4]) inversions++; } } return (inversions + zeroRow) % 2 == 1; // the index starts from 0, so the result of inversions should be ~~even~~ -&gt; odd } vector&lt;vector&lt;bool&gt;&gt; blocked(4, vector&lt;bool&gt;(4, false)); // the cells that have been already solved will be blocked const string arrows[4] = { &quot;â†‘&quot;, &quot;â†“&quot;, &quot;â†&quot;, &quot;â†’&quot; }; const int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }; // opposite to the arrows, because when we play the game, we don't move the empty cell, but move the numbers // but in the code, we move the empty cell, so the direction is opposite to the arrows // get the position of the number int getPos(Puzzle puzzle, int num) { for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] == num) return i; } return -1; } // find the path from the start to the end, do not need the puzzle itself, but 'blocked' is needed vector&lt;int&gt; findPath(int from, int to) { queue&lt;int&gt; q; vector&lt;int&gt; parent(16, -1); // the parent of the cell, -1 means not visited, -2 means the start cell q.push(from); parent[from] = -2; // using BFS to find the path, can be replaced by A* // but it's not necessary since the puzzle is small while (!q.empty()) { int cur = q.front(); q.pop(); if (cur == to) break; int x = cur / 4, y = cur % 4; for (int i = 0; i &lt; 4; i++) { int nx = x + dir[i][0], ny = y + dir[i][1]; if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4) continue; if (blocked[nx][ny]) continue; int next = cell2num(nx, ny); if (parent[next] != -1) continue; parent[next] = cur; q.push(next); } } if (parent[to] == -1) return vector&lt;int&gt;(); // get the path stack&lt;int&gt; transit; while (to != -2) { transit.push(to); to = parent[to]; } // get the direction of the path vector&lt;int&gt; path; while (transit.size() &gt; 1) { int from = transit.top(); transit.pop(); int to = transit.top(); int xFrom = from / 4, yFrom = from % 4; int xTo = to / 4, yTo = to % 4; for (int i = 0; i &lt; 4; i++) { if (xFrom + dir[i][0] == xTo &amp;&amp; yFrom + dir[i][1] == yTo) { path.push_back(i); break; } } } return path; } vector&lt;int&gt; move(Puzzle puzzle, int from, int to) { // find a whole path from the start to the end vector&lt;int&gt; path = findPath(from, to); if (path.empty()) return vector&lt;int&gt;(); vector&lt;int&gt; moves; // the moves that need to be done, including the empty cell int currX = from / 4, currY = from % 4; for (int i = 0; i &lt; path.size(); i++) { int nextX = currX + dir[path[i]][0], nextY = currY + dir[path[i]][1]; int zeroPos = getPos(puzzle, 0); int zeroX = zeroPos / 4, zeroY = zeroPos % 4; if (zeroPos != cell2num(nextX, nextY)) { // the empty cell is not next to the number, so the move is not valid // move the empty cell to the position next to the number // block the current cell blocked[currX][currY] = true; // find the path from the empty cell to the position next to the number vector&lt;int&gt; path2 = findPath(zeroPos, cell2num(nextX, nextY)); if (path2.empty()) return vector&lt;int&gt;(); // move the empty cell for (int j = 0; j &lt; path2.size(); j++) { int nextZeroX = zeroX + dir[path2[j]][0], nextZeroY = zeroY + dir[path2[j]][1]; moves.push_back(path2[j]); swap(puzzle[zeroX][zeroY], puzzle[nextZeroX][nextZeroY]); zeroX = nextZeroX, zeroY = nextZeroY; } // unblock the current cell blocked[currX][currY] = false; } // moves.push_back(path[i]); this is the move of the number, not the empty cell // move push_back opposite (0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2) moves.push_back(path[i] ^ 1); swap(puzzle[currX][currY], puzzle[nextX][nextY]); currX = nextX, currY = nextY; } return moves; } bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to) { // do not need to move if (from == to) return true; vector&lt;int&gt; moves = move(puzzle, from, to); if (moves.empty()) return false; for (int i = 0; i &lt; moves.size(); i++) { ans.push_back(moves[i]); int zeroPos = getPos(puzzle, 0); int zeroX = zeroPos / 4, zeroY = zeroPos % 4; swap(puzzle[zeroX][zeroY], puzzle[zeroX + dir[moves[i]][0]][zeroY + dir[moves[i]][1]]); } return true; } int main() { Puzzle puzzle(4, vector&lt;int&gt;(4)); for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j]; } if (!isValid(puzzle)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl; return 0; } if (!hasSolution(puzzle)) { cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl; return 0; } vector&lt;int&gt; ans; bool flag = true; // step 1: move [1] to pos 0 flag &amp;= calc(puzzle, ans, getPos(puzzle, 1), 0); blocked[0][0] = true; // step 2: move [2] to pos 1 flag &amp;= calc(puzzle, ans, getPos(puzzle, 2), 1); blocked[0][1] = true; // step 3: move [4] to pos 2 flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2); // step 4: if [3] is in pos 3 or (7 &amp;&amp; 3 is empty), we have to move it away // -&gt; move [3] to pos 10 if (getPos(puzzle, 3) == 3 || (getPos(puzzle, 3) == 7 &amp;&amp; getPos(puzzle, 0) == 3)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 10); blocked[2][2] = true; // move [4] back to pos 2, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2); blocked[2][2] = false; } blocked[0][2] = true; // step 5: move [3] to pos 6 flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 6); blocked[1][2] = true; // step 6: move [4] to pos 3 blocked[0][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 3); blocked[0][3] = true; // step 7: move [3] to pos 2 blocked[1][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 2); blocked[0][2] = true; // now we have [1] [2] [3] [4] in the right place, and they are blocked // step 8: move [5] to pos 4 flag &amp;= calc(puzzle, ans, getPos(puzzle, 5), 4); blocked[1][0] = true; // step 9: move [6] to pos 5 flag &amp;= calc(puzzle, ans, getPos(puzzle, 6), 5); blocked[1][1] = true; // step 10: move [8] to pos 6 flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6); // step 11: if [7] is in pos 7 or (11 &amp;&amp; 7 is empty), we have to move it away // -&gt; move [7] to pos 14 if (getPos(puzzle, 7) == 7 || (getPos(puzzle, 7) == 11 &amp;&amp; getPos(puzzle, 0) == 7)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 14); blocked[3][2] = true; // move [8] back to pos 6, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6); blocked[3][2] = false; } blocked[1][2] = true; // step 12: move [7] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 10); blocked[2][2] = true; // step 13: move [8] to pos 7 blocked[1][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 7); blocked[1][3] = true; // step 14: move [7] to pos 6 blocked[2][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 6); blocked[1][2] = true; // now we have [5] [6] [7] [8] in the right place, and they are blocked // step 15: move [13] to pos 8 flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8); // step 16: if 9 is in pos 12 or (13 &amp;&amp; 12 is empty), we have to move it away // -&gt; move [9] to pos 10 if (getPos(puzzle, 9) == 12 || (getPos(puzzle, 9) == 13 &amp;&amp; getPos(puzzle, 0) == 12)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 10); blocked[2][2] = true; // move [13] back to pos 8, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8); blocked[2][2] = false; } blocked[2][0] = true; // step 17: move [9] to pos 9 flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 9); blocked[2][1] = true; // step 18: move [13] to pos 12 blocked[2][0] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 12); blocked[3][0] = true; // step 19: move [9] to pos 8 blocked[2][1] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 8); blocked[2][0] = true; // now we have [9] [13] in the right place, and they are blocked // step 20: move [14] to pos 9 flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9); // step 21: if [10] is in pos 13 or (14 &amp;&amp; 13 is empty), we have to move it away // -&gt; move [10] to pos 11 if (getPos(puzzle, 10) == 13 || (getPos(puzzle, 10) == 14 &amp;&amp; getPos(puzzle, 0) == 13)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 11); blocked[2][3] = true; // move [14] back to pos 9, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9); blocked[2][3] = false; } blocked[2][1] = true; // step 22: move [10] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 10); blocked[2][2] = true; // step 23: move [14] to pos 13 blocked[2][1] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 13); blocked[3][1] = true; // step 24: move [10] to pos 9 blocked[2][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 9); blocked[2][1] = true; // now we have [10] [14] in the right place, and they are blocked // step 25: move [11] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 11), 10); blocked[2][2] = true; // step 26: move [12] to pos 11 flag &amp;= calc(puzzle, ans, getPos(puzzle, 12), 11); blocked[2][3] = true; // step 27: move [15] to pos 14 flag &amp;= calc(puzzle, ans, getPos(puzzle, 15), 14); blocked[3][2] = true; // now we have [11] [12] [15] in the right place, and they are blocked if (!flag) { cout &lt;&lt; &quot;Something went wrong&quot; &lt;&lt; endl; return 0; } // make the answer simpler, removing unnecessary moves for (int i = 0; i &lt; ans.size(); i++) { if ((ans[i] ^ ans[i + 1]) == 1) { ans.erase(ans.begin() + i); ans.erase(ans.begin() + i); i -= 2; // go back 2 steps, to make sure we didn't create another unnecessary move } } // print the answer cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; ans.size() &lt;&lt; &quot; moves):&quot; &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; arrows[ans[i]]; if (i % 5 == 4) cout &lt;&lt; ' '; } cout &lt;&lt; endl; return 0; } ä½ å¯èƒ½ä¼šé—®ï¼šä¸ºä»€ä¹ˆ move() å’Œ calc() ä¸èƒ½åˆå¹¶åœ¨ä¸€å—å„¿ï¼Ÿ ä¼˜è´¨ç­”æ¡ˆï¼šæˆ‘ä¸çŸ¥é“å¯ä»¥ï¼Œä½†æ˜¯æˆ‘ä¸æƒ³æ”¹äº†ã€‚ ä½ åˆä¼šé—®ï¼šä¸ºä»€ä¹ˆä½ è¿ä½è¿ç®—éƒ½æ”¹äº†ï¼Œå´ä¸æ„¿æ„æ”¹è¿™ä¸ªï¼Ÿ ä¼˜è´¨ç­”æ¡ˆï¼šå»å†™æš‘å‡ä½œä¸šäº†ã€‚[4] ç”± M1 é©±åŠ¨çš„ MacBook Air è¿ç®—ã€‚åœ¨å…¶ä»–çš„ç”µè„‘ä¸Šï¼Œè¿è¡Œæ—¶é—´å¯èƒ½æœ‰æ‰€ä¸åŒã€‚ â†©ï¸ https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213 â†©ï¸ https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222 â†©ï¸ å¦‚ä¸‹å›¾ï¼Œå…± 556 ä»½ã€‚ â†©ï¸ ","link":"https://oimaster.top/post/-jrYcZ0cc/"},{"title":"å¼ºè¿é€šåˆ†é‡ä¸ç¼©ç‚¹","content":"æœ€è¿‘å¤ä¹ äº†å…³äºå¼ºè¿é€šåˆ†é‡å’Œç¼©ç‚¹çš„çŸ¥è¯†ï¼Œæœ‰äº†å¾ˆå¤šæ–°çš„æ„Ÿæ‚Ÿï¼Œå†™ä¸€ç¯‡å­¦ä¹ ç¬”è®°å‡ºæ¥ä¾›è‡ªå·±æŸ¥é˜…ã€‚ å¼ºè¿é€šåˆ†é‡ å®šä¹‰ ã€å¼ºè¿é€šã€æŒ‡çš„æ˜¯åœ¨ä¸€ä¸ªæœ‰å‘å›¾ GGG ä¸­ï¼Œä»»æ„ä¸¤ç‚¹è¿é€šï¼Œä¹Ÿå°±æ˜¯è‡³å°‘å­˜åœ¨ä¸€æ¡è·¯å¾„ã€‚ ã€å¼ºè¿é€šåˆ†é‡ã€[1]æŒ‡çš„æ˜¯å°½å¯èƒ½å¤§çš„ã€å¼ºè¿é€šã€å­å›¾ã€‚ ä¾‹å¦‚ï¼Œåœ¨è¿™å¹…å›¾ä¸­ï¼Œå­å›¾ {1,2,5,6}\\{1, 2, 5, 6\\}{1,2,5,6} æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œè¿™æ˜¯å› ä¸ºå®ƒä»¬ä¹‹é—´ä¸¤ä¸¤å¯è¾¾ã€‚å­å›¾ {3}\\{3\\}{3} ä¸å­å›¾ {4}\\{4\\}{4} ä¹Ÿæ˜¯ä¸¤ä¸ªå¤§å°ä¸º 111 çš„å¼ºè¿é€šåˆ†é‡ã€‚ è§£æ³• æ±‚è§£å¼ºè¿é€šåˆ†é‡é—®é¢˜ï¼Œæœ‰å¤šç§ç®—æ³•ã€‚æœ¬æ–‡ä»‹ç» Tarjan ç®—æ³•ã€‚é¦–å…ˆï¼Œéœ€è¦äº†è§£ã€DFS ç”Ÿæˆæ ‘ã€ã€‚è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š å…¶ä¸­ï¼Œæœ‰è‹¥å¹²ç§è¾¹ã€‚ ã€æ ‘è¾¹ã€ï¼šæ¯æ¬¡æœç´¢åˆ°ä¸€ä¸ªæ²¡æœ‰è®¿é—®è¿‡çš„èŠ‚ç‚¹æ—¶ä¼šå½¢æˆä¸€æ¡æ ‘è¾¹ï¼› ã€è¿”ç¥–è¾¹ã€[2]ï¼šæŒ‡å‘è‡ªå·±ç¥–å…ˆèŠ‚ç‚¹çš„è¾¹ï¼› ã€æ¨ªå‰è¾¹ã€ï¼šåœ¨æœç´¢ä¸­é‡åˆ°äº†ä¸€ä¸ªå·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œä½†æ˜¯è¿™ä¸ªèŠ‚ç‚¹å¹¶ä¸æ˜¯è‡ªå·±çš„ç¥–å…ˆï¼› ã€å‰å‘è¾¹ã€ï¼šåœ¨æœç´¢æ—¶é‡åˆ°äº†è‡ªå·±å­æ ‘ä¸­çš„èŠ‚ç‚¹å½¢æˆï¼Œä¸”è¿™ä¸ªèŠ‚ç‚¹å·²ç»è¢«è®¿é—®è¿‡ï¼Œå³ä¸å’Œè‡ªå·±ç›¸é‚»ã€‚ å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ iiiï¼Œè®¾ dfnidfn_idfniâ€‹ ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„ dfs åºã€‚ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨ä¸Šå›¾ä¸­ï¼Œdfnidfn_idfniâ€‹ è¢«å†™åœ¨äº†æ¯ä¸ªèŠ‚ç‚¹å†…éƒ¨ã€‚åŒæ—¶ï¼Œè®¾ lowilow_ilowiâ€‹ è¡¨ç¤ºåœ¨ä»¥ iii ä¸ºæ ¹çš„å­æ ‘ä¸­çš„ä»»æ„ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œç»è¿‡æœ€å¤šä¸€æ¡éå­æ ‘å†…çš„è¾¹åï¼Œå¯ä»¥åˆ°è¾¾çš„èŠ‚ç‚¹ä¸­æœ€å°çš„ dfndfndfnã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸Šå›¾ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ lowlowlow å€¼ä»¥çº¢è‰²æ ‡åˆ°èŠ‚ç‚¹æ—è¾¹ã€‚ åœ¨æœç´¢ä¹‹å‰ï¼Œå…ˆäº†è§£ä¸€ä¸ªåŸºæœ¬çš„æ€§è´¨ã€‚å¦‚æœ uuu æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å†…ç¬¬ä¸€ä¸ªè¢«æœç´¢åˆ°çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼ºè¿é€šåˆ†é‡å†…å‰©ä¸‹çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½åœ¨ uuu çš„å­æ ‘ä¸­ï¼Œuuu ä¹Ÿè¢«ç§°ä¸ºè¿™ä¸ªå¼ºè¿é€šåˆ†é‡çš„**ã€æ ¹ã€**ã€‚å¯ä»¥ç®€å•åœ°è¯æ˜ä¸€ä¸‹ã€‚ å¦‚æœåœ¨è¿™ä¸ªå¼ºè¿é€šåˆ†é‡å†…è¿˜æœ‰ä¸€ä¸ªä¸åŒäº uuu çš„èŠ‚ç‚¹ vvvï¼Œä¸” vvv ä¸åœ¨ uuu çš„å­æ ‘ä¸­ï¼Œé‚£ä¹ˆå› ä¸ºå¼ºè¿é€šåˆ†é‡çš„å®šä¹‰ï¼Œå¿…é¡»ä¼šæœ‰ä¸€æ¡è·¯å¾„èƒ½ä» uuu åˆ° vvvã€‚æ­¤æ—¶ï¼Œè¿™æ¡è·¯å¾„ä¸Šä¸å¯èƒ½åªåŒ…å«æ ‘è¾¹ï¼Œä¸€å®šè¿˜æœ‰æ¨ªå‰è¾¹æˆ–è€…è¿”ç¥–è¾¹ã€‚ä½†æ˜¯æ¨ªå‰è¾¹å’Œè¿”ç¥–è¾¹çš„å‰ææ˜¯ vvv ä¸€å®šæ˜¯å·²ç»è¢«æœç´¢åˆ°äº†ï¼Œä¸ç¬¦åˆã€uuu æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å†…ç¬¬ä¸€ä¸ªè¢«æœç´¢åˆ°çš„èŠ‚ç‚¹ã€ï¼Œæ‰€ä»¥è¿™ä¸ªæ€§è´¨æˆç«‹ã€‚ åœ¨æœç´¢çš„æ—¶å€™ï¼Œä¼šé‡åˆ°å‡ ç§æƒ…å†µã€‚å‡è®¾ç°åœ¨æœç´¢åˆ°èŠ‚ç‚¹ uuuï¼Œæ­£çœ‹åˆ° uuu çš„ç›¸é‚»èŠ‚ç‚¹ vvvã€‚ vvv æ²¡æœ‰è¢«è®¿é—®è¿‡ã€‚æ­¤æ—¶é€’å½’æœç´¢ vvvï¼Œå¹¶ç›´æ¥ç»§æ‰¿ lowvlow_vlowvâ€‹ åˆ° lowulow_ulowuâ€‹ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœèŠ‚ç‚¹ vvv èƒ½è®¿é—®åˆ° lowvlow_vlowvâ€‹ï¼Œé‚£ä¹ˆ uuu åªéœ€è¦å¤šèµ°ä¸€æ¡æœ‰å‘è¾¹ä¹Ÿå¯ä»¥è®¿é—®åˆ° lowvlow_vlowvâ€‹ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ä½¿ lowulow_ulowuâ€‹ å–å°è€…ï¼› vvv å·²ç»è¢«è®¿é—®è¿‡ã€‚æ­¤æ—¶åˆéœ€è¦åˆ†æƒ…å†µè®¨è®ºï¼š vvv å±äºä¸€ä¸ªå·²çŸ¥çš„å¼ºè¿é€šåˆ†é‡å†…ã€‚æ­¤æ—¶ä¸éœ€è¦åšä»»ä½•äº‹æƒ…ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœ uuu ä¹‹å‰å±äº vvv çš„å¼ºè¿é€šåˆ†é‡å†…ï¼Œå°±ä¸€å®šä¼šä»¥ vvv çš„å­æ ‘èŠ‚ç‚¹å‡ºç°ã€‚è¿™æ˜æ˜¾æ˜¯ä¸ç¬¦åˆç›®å‰çš„æƒ…å†µçš„ï¼Œæ‰€ä»¥ç›´æ¥å¿½ç•¥ã€‚ vvv ä¸å±äºä¸€ä¸ªå·²çŸ¥çš„å¼ºè¿é€šåˆ†é‡å†…ã€‚æ ¹æ® lowlowlow å€¼çš„å®šä¹‰ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ dfnvdfn_vdfnvâ€‹ æ›´æ–° lowulow_ulowuâ€‹ã€‚ ä¸ºäº†åˆ¤æ–­ä¸Šé¢çš„ vvv æ˜¯å¦åœ¨ä¸€ä¸ªå·²çŸ¥çš„å¼ºè¿é€šåˆ†é‡å†…ï¼Œæœ‰ä¸€ç§æ–¹æ³•æ˜¯ç»´æŠ¤ä¸€ä¸ªæ ˆã€‚å°†ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡çš„èŠ‚ç‚¹æ”¾åœ¨ä¸€èµ·ï¼Œå½“å‘ç°åç»Ÿä¸€å¼¹å‡ºå¹¶è®°å½•ã€‚ å¦‚ä½•å‘ç°ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Ÿåœ¨ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œå¿…å®šæœ‰ä¸”ä»…æœ‰ 111 ä¸ª uuu ä½¿å¾— dfnu=lowudfn_u = low_udfnuâ€‹=lowuâ€‹ã€‚è¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯è¯¥å¼ºè¿é€šåˆ†é‡çš„æ ¹ã€‚å› ä¸ºåœ¨ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œæ ¹çš„ dfndfndfn ä¸€å®šæœ€å°ï¼Œæ‰€ä»¥ä¸ä¼šè¢«ä»»ä½•ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡å†…çš„å…¶ä»–èŠ‚ç‚¹æ‰€å½±å“ã€‚ ç¤ºä¾‹ ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œä¸å¦‚ä¸¾ä¸ªä¾‹å­ã€‚è¿™æ˜¯åŸå§‹çš„å›¾ã€‚ ä»èŠ‚ç‚¹ 111 å¯åŠ¨æœç´¢ã€‚ç»¿è‰²ä»£è¡¨æ­£åœ¨é€’å½’ä¸­çš„è¾¹ã€‚ç°è‰²ä»£è¡¨å·²ç»æœç´¢è¿‡çš„è¾¹ã€‚èŠ‚ç‚¹å†…éƒ¨çš„æ•°å­—ä»£è¡¨ç€å…¶ç¼–å·ï¼ˆä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œè¿™ä¸ªç¼–å·ä¹Ÿç­‰äºå…¶ dfndfndfnï¼‰ï¼ŒèŠ‚ç‚¹æ—è¾¹çš„ç»¿è‰²æ•°å­—ä¸ºè¯¥èŠ‚ç‚¹çš„ lowlowlowã€‚å³ä¾§ä¸ºæ ˆå†…ç©ºé—´ã€‚ æŒ‰ç…§é¡ºåºï¼Œæ¥ä¸‹æ¥åº”è¯¥æœç´¢ 222ã€‚ æŒ‰ç…§é¡ºåºï¼Œæ¥ä¸‹æ¥åº”è¯¥æœç´¢ 333ã€‚ æŒ‰ç…§é¡ºåºï¼Œæ¥ä¸‹æ¥åº”è¯¥æœç´¢ 444ã€‚ èŠ‚ç‚¹ 444 æ²¡æœ‰æŒ‡å‡ºå»çš„æœ‰å‘è¾¹ï¼Œæ— æ³•ç»§ç»­æœç´¢ã€‚æ­¤æ—¶å‘ç° low4=dfn4low_4 = dfn_4low4â€‹=dfn4â€‹ï¼Œäºæ˜¯åˆ¤å®š {4}\\{4\\}{4} ä¸ºå¼ºè¿é€šåˆ†é‡ï¼Œå¹¶å¼¹æ ˆã€‚ å›æº¯åˆ°èŠ‚ç‚¹ 333ã€‚ æ­¤æ—¶æ³¨æ„åˆ° 333 å·²ç»æ²¡æœ‰æ›´å¤šçš„æœ‰å‘è¾¹æŒ‡å‡ºå»ï¼Œåœæ­¢æ‹“å±•ã€‚å‘ç° low3=dfn3low_3 = dfn_3low3â€‹=dfn3â€‹ï¼Œåˆ¤æ–­ {3}\\{3\\}{3} ä¸ºå¼ºè¿é€šåˆ†é‡ï¼Œå¹¶å¼¹æ ˆã€‚ å›æº¯åˆ°èŠ‚ç‚¹ 222ã€‚ å‘ç°ä¸€æ¡æœ‰å‘è¾¹ (2,5)(2, 5)(2,5)ï¼Œäºæ˜¯å¼€å§‹æœç´¢èŠ‚ç‚¹ 555ã€‚ æ¥ä¸‹æ¥ï¼Œæœç´¢èŠ‚ç‚¹ 111ã€‚å‘ç°èŠ‚ç‚¹ 111 è¢«è®¿é—®è¿‡ä¸”åœ¨æ ˆä¸­ã€‚æ ¹æ®è§„åˆ™ï¼Œæ›´æ–° low5â†dfn1low_5 \\leftarrow dfn_1low5â€‹â†dfn1â€‹ã€‚ åŒæ ·åœ°ï¼Œæœç´¢èŠ‚ç‚¹ 444ã€‚èŠ‚ç‚¹ 444 æ›¾è¢«è®¿é—®è¿‡ä½†æ˜¯ä¸åœ¨æ ˆä¸­ã€‚æ ¹æ®ä¸Šé¢çš„è§„åˆ™ï¼Œå¾—çŸ¥ 444 ä¸€å®šå¤„åœ¨ä¸€ä¸ªå·²çŸ¥çš„å¼ºè¿é€šåˆ†é‡ä¸­ï¼Œè¿™ä¹Ÿæ˜¯æ»¡è¶³ç¤ºä¾‹çš„ã€‚æ‰€ä»¥ä¸åŠ¨ã€‚ ç”¨ low3low_3low3â€‹ æ›´æ–° low2low_2low2â€‹ï¼Œä½†æ˜¯å› ä¸º low3&gt;low2low_3 &gt; low_2low3â€‹&gt;low2â€‹ æ‰€ä»¥ä¸ç”¨åšä»»ä½•äº‹æƒ…ã€‚æ¥ä¸‹æ¥ï¼Œæœç´¢èŠ‚ç‚¹ 666ã€‚ å‘ç°è¿æ¥èŠ‚ç‚¹ 111 çš„æœ‰å‘è¾¹ã€‚èŠ‚ç‚¹ 111 æ›¾ç»è¢«è®¿é—®è¿‡ä¸”åœ¨æ ˆä¸­ã€‚æ›´æ–° low6low_6low6â€‹ã€‚ æ²¡æœ‰æ›´å¤šçš„è¾¹äº†ã€‚å‘ç° low6î€ =dfn6low_6 \\not = dfn_6low6â€‹î€ â€‹=dfn6â€‹ï¼Œä¸æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚ å›æº¯ã€‚ å›åˆ° 555 èŠ‚ç‚¹ã€‚æ³¨æ„æ­¤æ—¶æ ˆä¸­ä¸è¦å¼¹å‡º 666ã€‚ç”¨ low6low_6low6â€‹ æ›´æ–° low5low_5low5â€‹ã€‚å› ä¸ºä¸€æ ·å¤§æ‰€ä»¥ä¸ç”¨åšä»»ä½•äº‹æƒ…ã€‚ æ²¡æœ‰æ›´å¤šçš„è¾¹äº†ã€‚å‘ç° low5î€ =dfn5low_5 \\not = dfn_5low5â€‹î€ â€‹=dfn5â€‹ï¼Œä¸æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚ å›æº¯ã€‚ èŠ‚ç‚¹ 222 æ²¡æœ‰æ›´å¤šçš„è¾¹äº†ã€‚æ›´æ–° low2â†low5low_2 \\leftarrow low_5low2â€‹â†low5â€‹ã€‚ æ­¤æ—¶ 222 å·²ç»æ²¡æœ‰æ›´å¤šçš„è¾¹ã€‚å‘ç° low2î€ =dfn2low_2 \\not = dfn_2low2â€‹î€ â€‹=dfn2â€‹ï¼Œä¸æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚ å›æº¯ã€‚ ç”¨ low2low_2low2â€‹ æ›´æ–° low1low_1low1â€‹ï¼Œä½†æ˜¯å› ä¸ºä¸€æ ·å¤§æ‰€ä»¥ä»€ä¹ˆéƒ½ä¸ç”¨åšã€‚ æ­¤æ—¶å‘ç° low1low_1low1â€‹ æ²¡æœ‰æ›´å¤šè¾¹äº†ï¼Œäºæ˜¯å¼€å§‹åˆ¤æ–­ã€‚low1=dfn1low_1 = dfn_1low1â€‹=dfn1â€‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ111 æ˜¯æŸä¸ªå¼ºè¿é€šåˆ†é‡çš„æ ¹ã€‚ å¼€å§‹å¼¹æ ˆï¼Œç›´åˆ°æ ˆé¡¶ä¸º 111ï¼Œå¹¶è®°å½•ä¸‹æ¥æ‰€å¼¹å‡ºæ¥çš„èŠ‚ç‚¹ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„å¼ºè¿é€šåˆ†é‡ã€‚ æ³¨æ„è¦è¿å¸¦ 111 ä¸€èµ·å¼¹å‡ºã€‚ç°åœ¨å·²ç»æ¢ç´¢åˆ°äº†æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚å›åˆ°ä¸»å‡½æ•°ã€‚ è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»æ‰¾åˆ°äº†æ‰€æœ‰çš„å¼ºè¿é€šåˆ†é‡ {1,2,5,6}\\{1, 2, 5, 6\\}{1,2,5,6} ã€ {3}\\{3\\}{3} ä¸ {4}\\{4\\}{4}ã€‚ ä»£ç  int n, m; vector&lt;int&gt; e[10010]; int dfn[10010]; int low[10010]; int cnt; int sid[10010]; int siz[10010]; int scnt; bool inStack[10010]; bool vis[10010]; stack&lt;int&gt; st; void tarjan(int u) { vis[u] = true; ++cnt; dfn[u] = low[u] = cnt; st.push(u); inStack[u] = true; for (auto i : e[u]) if (!vis[i]) { tarjan(i); low[u] = min(low[u], low[i]); } else if (inStack[i]) low[u] = min(low[u], dfn[i]); if (dfn[u] == low[u]) { ++scnt; while (st.top() != u) { sid[st.top()] = scnt; ++siz[scnt]; inStack[st.top()] = false; st.pop(); } st.pop(); sid[u] = scnt; ++siz[scnt]; inStack[u] = false; } } ç¼©ç‚¹ æ²¡ä»€ä¹ˆæŠ€å·§ï¼Œå°±æ˜¯æŠŠå¼ºè¿é€šåˆ†é‡çš„ç¯å½“ä½œä¸€ä¸ªæ–°çš„ç‚¹ï¼Œé‡æ–°æ„é€ ä¸€éå›¾å³å¯ã€‚æ³¨æ„ä¸è¦å‡ºç°è‡ªç¯ã€‚ æ„é€ å‡ºæ¥çš„ä¸€å®šæ˜¯ä¸€ä¸ª DAG[3]ã€‚ ä»£ç  for (int i = 1; i &lt;= n; ++i) e[i].clear(); for (int i = 1; i &lt;= m; ++i) { int u = sid[ex[i]]; int v = sid[ey[i]]; if (u != v) e[u].push_back(v); } ä¹ é¢˜ ç¼©ç‚¹æ¨¡æ¿ é¢˜ç›®æè¿° é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P3387 è§£æ³• å®Œæˆ Tarjanã€ç¼©ç‚¹åï¼Œè·‘ä¸€éæ‹“æ‰‘æ’åºå°±å¯ä»¥è§£å†³ã€‚ ä»£ç å®ç° #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; int a[10010]; vector&lt;int&gt; e[10010]; int ex[100010]; int ey[100010]; int dfn[10010]; int low[10010]; bool inStack[10010]; bool vis[10010]; stack&lt;int&gt; st; int cnt; vector&lt;int&gt; newe[10010]; int sid[10010]; int siz[10010]; int scnt; queue&lt;int&gt; topo; int dis[10010]; int deg[10010]; int ans; void tarjan(int u) { vis[u] = true; ++cnt; dfn[u] = cnt; low[u] = cnt; st.push(u); inStack[u] = true; for (auto i : e[u]) if (vis[i] == false) { tarjan(i); low[u] = min(low[u], low[i]); } else if (inStack[i] == true) low[u] = min(low[u], dfn[i]); if (dfn[u] == low[u]) { ++scnt; while (st.top() != u) { sid[st.top()] = scnt; siz[scnt] += a[st.top()]; inStack[st.top()] = false; st.pop(); } st.pop(); sid[u] = scnt; siz[scnt] += a[u]; inStack[u] = false; } } void toposort() { for (int i = 1; i &lt;= scnt; ++i) if (deg[i] == 0) { dis[i] = siz[i]; topo.push(i); } while (!topo.empty()) { int now = topo.front(); topo.pop(); for (auto i : newe[now]) { dis[i] = max(dis[i], dis[now] + siz[i]); --deg[i]; if (deg[i] == 0) topo.push(i); } } } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; ex[i] &gt;&gt; ey[i]; e[ex[i]].push_back(ey[i]); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i); for (int i = 1; i &lt;= m; ++i) { int u = sid[ex[i]]; int v = sid[ey[i]]; if (u != v) { newe[u].push_back(v); ++deg[v]; } } toposort(); for (int i = 1; i &lt;= scnt; ++i) ans = max(ans, dis[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0; } æ€»ç»“ è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæœ‰ç”¨çš„ç®—æ³•ã€‚ä¸å°‘å›¾è®ºé—®é¢˜å¯ä»¥é€šè¿‡ Tarjan è½¬æ¢æˆ DAGï¼Œç„¶åè¿›è¡Œæ‹“æ‰‘æ’åºç­‰æ“ä½œï¼Œå¯ä»¥åœ¨å›¾ä¸Šè¿›è¡ŒåŠ¨æ€è§„åˆ’ã€‚ åœ¨ ä¹‹å‰çš„ä¸€ç¯‡æ–‡ç«  ä¸­ï¼Œå¹¶æœªè¯¦ç»†è§£é‡Šè¿™æ£µã€DFS ç”Ÿæˆæ ‘ã€ï¼Œåªæ˜¯ç§°ä¸ºã€ä¸€æ£µæ ‘ã€[4]äº†ä¹‹ã€‚è¯»è€…ä¸å¦¨å›å¤´çœ‹çœ‹ï¼Œå¯èƒ½ä¼šæœ‰æ›´æ·±çš„æ”¶è·ã€‚ å¦å¤–ï¼Œè¯·è®©æˆ‘è¯´ä¸€å¥ï¼Œã€è¿™äº›å›¾ç‰‡çœŸçš„ç´¯æ­»æˆ‘äº†ã€ï¼ Strongly Connected Componentsï¼Œç¼©å†™ä¸º SCCã€‚ â†©ï¸ ä¹Ÿå¯ä»¥ç§°ä¸ºã€åå‘è¾¹ã€ã€ã€å›è¾¹ã€ï¼Œè‹±æ–‡ä¸ºã€back edgeã€ã€‚ â†©ï¸ Directed Acyclic Graphï¼Œæœ‰å‘æ— ç¯å›¾ã€‚ â†©ï¸ ã€å¯ä»¥å°†ä¸€å¼ å›¾çœ‹ä½œä¸€æ£µæ ‘ã€ã€‚ â†©ï¸ ","link":"https://oimaster.top/post/29iMUCdw4/"},{"title":"å‰²ç‚¹ä¸æ¡¥","content":"æœ€è¿‘å­¦ä¹ äº†å…³äºå‰²ç‚¹å’Œæ¡¥çš„çŸ¥è¯†ï¼Œå†™ä¸€ç¯‡å­¦ä¹ ç¬”è®°å‡ºæ¥ä¾›è‡ªå·±å¤ä¹ ã€‚ å‰²ç‚¹ å®šä¹‰ åœ¨ä¸€ä¸ªæ— å‘å›¾ä¸­ï¼Œå¦‚æœåˆ é™¤ä¸€ä¸ªç‚¹ä»¥åŠä¸å®ƒç›¸é‚»çš„è¾¹åï¼Œå›¾ä¸­çš„è¿é€šå—æ•°é‡å¢åŠ ï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸ªç‚¹ä¸º**ã€å‰²ç‚¹ã€**ã€‚ è¿™é‡Œæœ‰ä¸€å¼ å›¾ï¼Œå¯ä»¥æ›´æ¸…æ¥šåœ°ç†è§£ä¸€ä¸‹ã€‚ åœ¨è¿™å¼ å›¾ä¸­ï¼Œå¦‚æœåˆ é™¤äº†èŠ‚ç‚¹ 555ï¼Œé‚£ä¹ˆå›¾å°±ä¼šå˜æˆè¿™æ ·ï¼š å›¾ä¸­çš„è¿é€šå—ä¸ªæ•°ä» 111 å˜æˆäº† 222ï¼Œå¯è§èŠ‚ç‚¹ 555 å°±æ˜¯è¿™å¼ å›¾çš„ã€å‰²ç‚¹ã€ã€‚ è§£æ³• æ±‚è§£å›¾ä¸­çš„å‰²ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨ Tarjan ç®—æ³•ã€‚ é¦–å…ˆï¼Œä»¤ dfnidfn_idfniâ€‹ ä¸ºèŠ‚ç‚¹ iii çš„ dfs åºã€‚é€šè¿‡ dfsï¼Œå¯ä»¥å°†ä¸€å¼ å›¾çœ‹ä½œä¸€æ£µæ ‘ã€‚åˆšæ‰çš„å›¾å¯ä»¥è¢«æ ‡è®°æˆè¿™æ ·ã€‚å…¶ä¸­ï¼Œå†èŠ‚ç‚¹ iii æ—è¾¹çš„çº¢è‰²æ•°å­—ä»£è¡¨ dfnidfn_idfniâ€‹ï¼Œè¢«çº¢è‰²æ ‡è®°çš„è¾¹ä¸ºæ ‘ä¸Šçš„è¾¹ã€‚ æ¥ä¸‹æ¥ï¼Œå¯¹äºæ¯ä¸€ä¸ªç‚¹ iiiï¼Œè®¾ lowilow_ilowiâ€‹ è¡¨ç¤ºä»ç‚¹ iii çš„å­æ ‘ä¸­çš„ä»»æ„ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œç»è¿‡æœ€å¤šä¸€æ¡éå­æ ‘å†…çš„è¾¹åï¼Œå¯ä»¥åˆ°è¾¾çš„èŠ‚ç‚¹ä¸­æœ€å°çš„ dfndfndfnã€‚ ä¸ºäº†æ–¹ä¾¿æŸ¥çœ‹ï¼Œæˆ‘æ•´ç†äº†ä¸€ä¸‹è¿™å¼ å›¾ï¼Œä½¿å®ƒçœ‹ä¸Šå»åƒæ£µæ ‘ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨ä¸Šå›¾ä¸­ï¼Œå¦‚æœæŠŠèŠ‚ç‚¹ 111 çœ‹ä½œæ ¹ï¼Œlowlowlow æ•°ç»„çš„å€¼å°±ä¸º [1,1,1,1,1,3][1, 1, 1, 1, 1, 3][1,1,1,1,1,3]ã€‚ ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæˆ‘è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆ low6low_6low6â€‹ ä¸º 333ã€‚åœ¨ 666 çš„å­æ ‘ä¸­ï¼Œåªæœ‰ 666 ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¾¹ (5,6)(5, 6)(5,6) å¹¶ä¸å±äº 666 å­æ ‘å†…çš„ä¸€æ¡è¾¹ã€‚æ‰€ä»¥ï¼Œèƒ½å»åˆ°çš„ dfndfndfn æœ€å°çš„èŠ‚ç‚¹ç¼–å·ä¸º 555ï¼Œç»è¿‡ (5,6)(5, 6)(5,6) ä¸€æ¡éå­æ ‘è¾¹ï¼Œlow6â†dfn5low_6 \\leftarrow dfn_5low6â€‹â†dfn5â€‹ã€‚ åŒæ ·åœ°ï¼Œå¯¹äºèŠ‚ç‚¹ 222ï¼Œå®ƒçš„å­æ ‘ä¸­æœ‰èŠ‚ç‚¹ 2,3,4,5,62, 3, 4, 5, 62,3,4,5,6ã€‚å¯ä»¥å¾—åˆ°çš„æœ€å°çš„ dfndfndfn ä¾¿æ˜¯é€šè¿‡å­æ ‘è¾¹ (2,5)(2, 5)(2,5)ã€(5,3)(5,3)(5,3)ï¼Œå†ç»è¿‡ä¸€æ¡éå­æ ‘è¾¹ (3,1)(3, 1)(3,1) åˆ°è¾¾èŠ‚ç‚¹ 111ã€‚äºæ˜¯ï¼Œlow2â†dfn1low_2 \\leftarrow dfn_1low2â€‹â†dfn1â€‹ã€‚æ³¨æ„è¿™é‡Œæ— æ³•ç›´æ¥ä» (2,1)(2, 1)(2,1) åˆ°è¾¾èŠ‚ç‚¹ 111ï¼Œå› ä¸ºè¾¹ (2,1)(2, 1)(2,1) å¹¶ä¸æ˜¯ä¸€æ¡ä»¥ 222 ä¸ºæ ¹çš„å­æ ‘è¾¹ã€‚ æ‰€ä»¥ï¼Œå¦‚æœèŠ‚ç‚¹ iii çš„å­æ ‘ä¸­å­˜åœ¨ä¸€ç‚¹ jjjï¼Œä½¿å¾— lowjâ‰¥dfnilow_j \\ge dfn_ilowjâ€‹â‰¥dfniâ€‹ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¾—åˆ° iii ä¸€å®šæ˜¯ä¸€ä¸ªå‰²ç‚¹ã€‚åŸå› æ˜¯ï¼Œæ ¹æ®ä¸Šé¢çš„å®šä¹‰ï¼Œå¦‚æœè¦ä» jjj åˆ°ä»»ä½•ä¸€ä¸ªæ»¡è¶³ dfnk&lt;dfnidfn_k &lt; dfn_idfnkâ€‹&lt;dfniâ€‹ çš„èŠ‚ç‚¹ kkkï¼Œæ˜¯æ²¡æœ‰åŠæ³•ç›´æ¥ä» jjj çš„å­æ ‘åˆ°è¾¾çš„ï¼Œå¿…é¡»é€šè¿‡ iiiã€‚å› æ­¤ï¼Œå¦‚æœåˆ é™¤ iiiï¼Œjjj å’Œ kkk å°±æ— æ³•äº’ç›¸åˆ°è¾¾äº†ï¼Œè¿é€šå—æ•°é‡å¢åŠ ï¼Œiii æ˜¯ä¸€ä¸ªå‰²ç‚¹ã€‚ ä½†æ˜¯æœ‰ä¸€ä¸ªç‚¹æ˜¯ç‰¹æ®Šçš„ï¼Œè¿™å°±æ˜¯æ•´æ£µæ ‘çš„æ ¹ã€‚è¿™ä¸ªèŠ‚ç‚¹æ— æ³•é€šè¿‡ä¸Šé¢çš„æ–¹æ³•è§£å†³ï¼Œå› ä¸ºå®ƒä¸æ˜¯ä»»ä½•èŠ‚ç‚¹çš„å­©å­ã€‚ä¸è¿‡ä¹Ÿä¸å›°éš¾ã€‚å¦‚æœæ ¹èŠ‚ç‚¹ 111 æœ‰ 222 ä¸ªåŠä»¥ä¸Šçš„å­æ ‘ï¼Œé‚£ä¹ˆå¦‚æœåˆ‡æ–­ 111ï¼Œè¿™äº›å­æ ‘å°†æ— æ³•è¿æ¥ã€‚æ³¨æ„ï¼Œå­æ ‘ä¹‹é—´æ˜¯ä¸å¯èƒ½æœ‰è¾¹è¿æ¥çš„ï¼Œè¿™æ˜¯å› ä¸ºåœ¨è·å¾—å­æ ‘çš„ dfs ä¸­ï¼Œèƒ½ä¸ä¸€æ£µå­æ ‘ç›¸è¿çš„èŠ‚ç‚¹å…¨éƒ½ä¼šè¢«å½’åˆ°ä¸€ä¸ªå­æ ‘ä¸­ã€‚ ä»£ç  é¢˜ç›®é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P3388 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int n, m; vector&lt;int&gt; e[20010]; vector&lt;int&gt; p; int dfn[20010]; int low[20010]; int cnt; void tarjan(int u, bool root) { int tot = 0; // dfs åº ++cnt; dfn[u] = cnt; low[u] = cnt; for (auto i : e[u]) if (dfn[i]) low[u] = min(low[u], dfn[i]); // i ä¸æ˜¯ u çš„å­æ ‘ã€‚(i, u) æ˜¯ä¸€æ¡éå­æ ‘è¾¹ã€‚ else { tarjan(i, false); low[u] = min(low[u], low[i]); // i æ˜¯ u çš„å­æ ‘ï¼Œæ‰€ä»¥ u å¯ä»¥ç›´æ¥æ”¶å– i çš„ç­”æ¡ˆã€‚ if (low[i] &gt;= dfn[u]) ++tot; } if ((root == true &amp;&amp; tot &gt; 1) || (root == false &amp;&amp; tot &gt; 0)) p.push_back(u); } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i, true); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; dfn[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; low[i] &lt;&lt; ' '; cout &lt;&lt; endl; sort(p.begin(), p.end()); cout &lt;&lt; p.size() &lt;&lt; endl; for (auto i : p) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl; } æ¡¥ å®šä¹‰ åœ¨ä¸€ä¸ªæ— å‘å›¾ä¸­ï¼Œå¦‚æœåˆ é™¤ä¸€æ¡è¾¹åï¼Œå›¾ä¸­çš„è¿é€šå—æ•°é‡å¢åŠ ï¼Œé‚£ä¹ˆå°±ç§°è¿™æ¡è¾¹ä¸º**ã€æ¡¥ã€**[1]ã€‚ è¿™é‡Œè¿˜æ˜¯é‚£å¼ å›¾ï¼Œå¯ä»¥æ›´æ¸…æ¥šåœ°ç†è§£ä¸€ä¸‹ã€‚ åœ¨è¿™å¼ å›¾åï¼Œå¦‚æœåˆ é™¤äº†è¾¹ (5,6)(5, 6)(5,6)ï¼Œé‚£ä¹ˆå›¾ä¼šå˜æˆè¿™æ ·ï¼š å›¾ä¸­çš„è¿é€šå—ä¸ªæ•°ä» 111 å˜æˆäº† 222ï¼Œå¯è§è¾¹ (5,6)(5, 6)(5,6) å°±æ˜¯è¿™å¼ å›¾çš„ã€æ¡¥ã€ã€‚ è§£æ³• ä¸åˆšæ‰çš„è§£æ³•ç±»ä¼¼ã€‚ å°† lowlowlow çš„å®šä¹‰ç¨å¾®ä¿®æ”¹ä¸€ä¸‹ï¼Œä¿®æ”¹çš„åœ°æ–¹åŠ ç²—æ˜¾ç¤ºã€‚å¯¹äºæ¯ä¸€ä¸ªç‚¹ iiiï¼Œè®¾ lowilow_ilowiâ€‹ è¡¨ç¤ºä»ç‚¹ iii çš„å­æ ‘ä¸­çš„ä»»æ„ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œç»è¿‡æœ€å¤šä¸€æ¡éå­æ ‘å†…çš„è¾¹ä¸”è¿™æ¡è¾¹ä¸è¿æ¥è‡ªå·±çš„çˆ¶äº²ï¼Œå¯ä»¥åˆ°è¾¾çš„èŠ‚ç‚¹ä¸­æœ€å°çš„ dfndfndfnã€‚ å¯¹äºä¿®æ”¹åçš„ lowlowlowï¼Œå¯ä»¥å¾—åˆ°ï¼Œå¦‚æœèŠ‚ç‚¹ uuu æ˜¯èŠ‚ç‚¹ vvv çš„çˆ¶äº²ï¼Œä¸” dfnu&lt;lowvdfn_u &lt; low_vdfnuâ€‹&lt;lowvâ€‹ï¼Œé‚£ä¹ˆè¾¹ (u,v)(u, v)(u,v) æ˜¯æ¡¥ã€‚ ç†ç”±ï¼šå‡è®¾ (u,v)(u, v)(u,v) ä¸æ˜¯æ¡¥ï¼Œé‚£ä¹ˆå½“åˆ é™¤è¾¹ (u,v)(u, v)(u,v) åï¼Œvvv ä¸€å®šå¯ä»¥é€šè¿‡è¿æ¥è‡ªå·±å­æ ‘çš„ä¸€äº›è¾¹è·³åˆ° uuu æˆ–è€… dfndfndfn å°äº uuu çš„ç‚¹ã€‚è¦æƒ³è¿™æ ·ï¼Œå°±ä¼šæœ‰ dfnuâ‰¥lowvdfn_u \\ge low_vdfnuâ€‹â‰¥lowvâ€‹ï¼Œä¸ä¸Šé¢çš„å¼å­çŸ›ç›¾äº†ã€‚æ‰€ä»¥ (u,v)(u, v)(u,v) ä¸€å®šæ˜¯æ¡¥ã€‚ é‚£ä¹ˆä¸ºä»€ä¹ˆéœ€è¦ä¿®æ”¹å®šä¹‰ï¼Ÿå¦‚æœä¸ä¿®æ”¹å®šä¹‰ï¼Œé‚£ä¹ˆ vvv ä¸€å®šå¯ä»¥é€šè¿‡è¿æ¥è‡ªå·±çˆ¶äº²çš„è¾¹ç›´æ¥è·³åˆ° uuuï¼Œå°±ä¸å¯èƒ½æ‰¾åˆ°ä»»ä½•çš„æ¡¥ã€‚ ä»£ç  æäº¤é“¾æ¥æš‚æ—¶æ²¡æœ‰ã€‚ å¦‚æœæœ‰é‡è¾¹çš„è¯ï¼Œä¸‹é¢çš„ä»£ç å°±ä¸èƒ½é€šè¿‡äº†ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœæœ‰é‡è¾¹çš„è¯ï¼Œä»£ç ç¬¬ 171717 è¡Œå°±ä¼šå¿½ç•¥æ‰é‡è¾¹ã€‚è§£å†³è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡é“¾å¼å‰å‘æ˜Ÿç­‰å­˜å‚¨æ— å‘å›¾ï¼Œä½¿å¾—æ­£å‘è¾¹ä¸åå‘è¾¹å­˜åœ¨ä¸€èµ·ï¼Œæ‹¿åˆ°è¾¹ ididid åé€šè¿‡ idâŠ•1id \\oplus 1idâŠ•1 ç­‰æ“ä½œåˆ¤æ–­æ˜¯å¦å±äºä¸€æ¡æ— å‘è¾¹ï¼Œå…¶ä¸­ âŠ•\\oplusâŠ• è¡¨ç¤ºå¼‚æˆ–ã€‚ #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int n, m; vector&lt;int&gt; e[20010]; vector&lt;pair&lt;int, int&gt;&gt; p; int dfn[20010]; int low[20010]; int cnt; void tarjan(int u, int fa) { ++cnt; dfn[u] = cnt; low[u] = cnt; for (auto i : e[u]) if (dfn[i]) { if (i == fa) // æ›´æ”¹å®šä¹‰ï¼Œå¿½ç•¥æ‰ä¸çˆ¶äº²è¿æ¥çš„è¾¹ã€‚å‰ææ˜¯æ²¡æœ‰é‡è¾¹ continue; low[u] = min(low[u], dfn[i]); } else { tarjan(i, u); low[u] = min(low[u], low[i]); if (low[i] &gt; dfn[u]) // ç»†å¾®çš„æ›´æ”¹ p.emplace_back(u, i); } } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i, 0); sort(p.begin(), p.end()); cout &lt;&lt; p.size() &lt;&lt; endl; for (auto i : p) cout &lt;&lt; i.first &lt;&lt; '-' &lt;&lt; i.second &lt;&lt; ' '; cout &lt;&lt; endl; } æ¡¥ä¹Ÿå«åšå‰²è¾¹ã€‚ â†©ï¸ ","link":"https://oimaster.top/post/Zfjel35ew/"}]}