{"posts":[{"title":"当你看到一道题……","content":"当你看到了一道时限 1000ms 的题🤔…… 不错，我要做这道题！💪 本地测试一下！ 时间就差一点！差一点，交交看！🤞 这怎么全挂了啊……不可能！😱 时限 1000ms 改成 2000ms，看你过不过。🤔 过了，赶紧改回来！😅 改回来了，这样又不会有人过了！ 好耶！🎉 肯定不是我的代码问题！ ","link":"https://oimaster.top/post/VDodg3tO5/"},{"title":"打算写假期日报！","content":"开创一个日报，想通过这种方式督促自己干点正事。这个假期无特殊情况每天都写。有特殊情况将会在下一次写的时候说明。 每一个日报会包括以下的内容。 干什么系列 今天要干什么 今天干了什么 今天没干什么 明天要干什么 情绪系列 今天心情怎么样 今天为什么这样 其他 特殊地，如果当日发布了其他文章，日报可以不写。 希望大家督促我完成这个任务。对于所有的日报，请从 #日报 标签或顶栏进入，不显示在主页列表中或归档页面。 如果您觉得我做得不好，请从日报页面底部的评论区炸我一下。 日报从 2023-07-05 开始写。日报在列表中显示时右侧没有配图。 ","link":"https://oimaster.top/post/gb9I1Pn8V/"},{"title":"用计算机解决 15 数码问题","content":"期末考试阶段，有不少压力。这时候，看到了一个小玩具。 我认为这有助于我放松。于是，我尝试解决它。然而，这花了我 5 分钟左右。 我感到很不服气。我打算征服它。 宽（广）度优先搜索 我打算使用电脑提升解题速度。刚开始，我认为这不难，应该在二十几步内完成。 此时，使用深度优先搜索显然不适合，因为在一步错误下很可能分叉出很多种可能。于是我打算用宽搜。 因为才完成一个 Vue 项目，所以我顺手写了一点 JS 代码（现在被我删了，很可惜你们看不到）。当我按下回车后，我的 Node.js 瞬间卡死了。 我以为可能是 Javascript 执行速度太慢，就重写了一份 C++ 代码。仍然很慢。已经到了深夜，我便回去复习了。 A* 这事情本来结束了的，然而我在晚上玩耍时看到了一个网站。 它提供的样例是 5,1,4,7,2,11,3,8,9,6,14,15,13,10,0,12，一共有 19 步，但是它瞬间就解决了。 我查看了它的源代码。它使用了启发式搜索。我不能落后。 因为 C++ 里面提供了 priority_queue，再加上 Javascript 在复杂计算时太慢了，所以我优先使用 C++。 思路是这样的： 对于每一个节点，遍历所有的数码； 对于每一个数码，计算数码应该在的位置； 接下来，计算当前位置与正确位置的距离，并累加。 这样，得到了节点的分数。据此进行 A*。 另外，因为使用一整个数组搜索太不方便，我使用了 getHash() 函数进行哈希。实际上，由于我用的是 unsigned long long 类型，所以不需要取模，也不会有重复的数值。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ctime&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;map&gt; using namespace std; bool isValid(vector&lt;vector&lt;int&gt;&gt; puzzle) { // verify size if (puzzle.size() != 4) return false; for (int i = 0; i &lt; 4; i++) { if (puzzle[i].size() != 4) return false; } bool exist[16] = { false }; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (puzzle[i][j] &lt; 0 || puzzle[i][j] &gt; 15) return false; if (exist[puzzle[i][j]]) return false; exist[puzzle[i][j]] = true; } } return true; } unsigned long long getHash(vector&lt;vector&lt;int&gt;&gt; puzzle) { unsigned long long hash = 0; for (int i = 0; i &lt; 16; i++) { hash = hash * 16 + puzzle[i / 4][i % 4]; } return hash; } int getScore(vector&lt;vector&lt;int&gt;&gt; puzzle) { int score = 0; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (puzzle[i][j] == 0) continue; score += abs(i - (puzzle[i][j] - 1) / 4) + abs(j - (puzzle[i][j] - 1) % 4); } } return score; } int main() { vector&lt;vector&lt;int&gt;&gt; puzzle(4, vector&lt;int&gt;(4)); for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j]; } int time = clock(); if (!isValid(puzzle)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl; return 0; } // A* search priority_queue&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;, vector&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;, greater&lt;pair&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&gt;&gt; pq; set&lt;unsigned long long&gt; visited; pq.push(make_pair(getScore(puzzle), puzzle)); visited.insert(getHash(puzzle)); map&lt;unsigned long long, unsigned long long&gt; parent; map&lt;unsigned long long, char&gt; direction; map&lt;unsigned long long, int&gt; depth; map&lt;unsigned long long, int&gt; cost; while (!pq.empty()) { vector&lt;vector&lt;int&gt;&gt; cur = pq.top().second; pq.pop(); if (getScore(cur) == 0) { // print solution vector&lt;unsigned long long&gt; path; unsigned long long curHash = getHash(cur); while (curHash != getHash(puzzle)) { path.push_back(curHash); curHash = parent[curHash]; } reverse(path.begin(), path.end()); cout &lt;&lt; &quot;Solution:&quot; &lt;&lt; endl; for (int i = 0; i &lt; path.size(); i++) { cout &lt;&lt; direction[path[i]]; if (i % 5 == 4) cout &lt;&lt; ' '; } cout &lt;&lt; endl; cout &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1.0 / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } int curDepth = depth[getHash(cur)]; int curCost = cost[getHash(cur)]; int zeroX = -1, zeroY = -1; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (cur[i][j] == 0) { zeroX = i; zeroY = j; break; } } } // move up if (zeroX &gt; 0) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX - 1][zeroY]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'U'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move down if (zeroX &lt; 3) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX + 1][zeroY]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'D'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move left if (zeroY &gt; 0) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX][zeroY - 1]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'L'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } // move right if (zeroY &lt; 3) { vector&lt;vector&lt;int&gt;&gt; next = cur; swap(next[zeroX][zeroY], next[zeroX][zeroY + 1]); unsigned long long nextHash = getHash(next); if (visited.find(nextHash) == visited.end()) { visited.insert(nextHash); parent[nextHash] = getHash(cur); direction[nextHash] = 'R'; depth[nextHash] = curDepth + 1; cost[nextHash] = curCost + 1; pq.push(make_pair(curCost + 1 + getScore(next), next)); } } } cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl; return 0; } 运行起来大概是这样的[1]： oimaster@kafuu 23-07-01 16:02:33 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b oimaster@kafuu 23-07-01 16:02:45 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 9 5 1 4 3 7 2 8 6 0 10 11 13 14 15 12 Solution: ULURR DLDLU URRDL DRRD Time: 1.758ms 然后我就发了条空间。 快一点的 A* 当我发出去后，我意识到自己的行为十分愚蠢。A* 算法很多人都会。然而，因为我使用了大量的 STL，但是编译时连 -O2 都没有加上，所以很容易被超越。 吓得我赶紧加上了 -Ofast。可以发现确实快了不少。 oimaster@kafuu 23-07-01 16:24:10 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b oimaster@kafuu 23-07-01 16:24:16 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 3 5 7 4 6 9 2 12 0 13 11 14 10 1 8 15 Solution: DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD Time: 1438.26ms oimaster@kafuu 23-07-01 16:24:19 ~/Documents/code/puzzle &gt;&gt;&gt; g++ puzzle.cpp --std=c++2b -Ofast oimaster@kafuu 23-07-01 16:24:29 ~/Documents/code/puzzle &gt;&gt;&gt; ./a.out 3 5 7 4 6 9 2 12 0 13 11 14 10 1 8 15 Solution: DRULD RUULD RUULD RRDDR UULDD RUULU LDDDR URD Time: 265.271ms oimaster@kafuu 23-07-01 16:24:32 ~/Documents/code/puzzle &gt;&gt;&gt; 立刻发了条空间刷新我的记录。两条空间间隔不到十分钟。显然是加了点编译优化选项，改不了多少代码。 位运算版 A* 如上面所说，第二天下午，我就去写了位运算。这个比较麻烦。首先，让我们思考如何表示一个棋盘。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ 将所有的空格换成 000，那么可以发现所有的数字都是 [0,16)\\left[0, 16\\right)[0,16) 中的整数，很方便位运算。 按照从上到下，从左到右的顺序，就可以把上面的棋盘转换成十六进制： (123456789abcdef0)16=(1311768467463790320)10\\left(123456789abcdef0\\right)_{16} = \\left(1311768467463790320\\right)_{10} (123456789abcdef0)16​=(1311768467463790320)10​ 其中，每一个数位代表着一个位置上的数字。 对于这个大数字，我们思考如何存储它。unsigned long long 可以吗？它的范围是 [0,264−1]\\left[0, 2^{64}-1\\right][0,264−1]，也就是一直到 184467440737095516151844674407370955161518446744073709551615。远远大于 131176846746379032013117684674637903201311768467463790320，放心吧。 所以就可以写出输入： #define puzzle unsigned long long puzzle p = 0; for (int i = 0; i &lt; 16; i++) { int x; cin &gt;&gt; x; p = (p &lt;&lt; 4) + x; } 接下来，就是处理移动。这将会是一个大工程。首先，让我们找到 000 所在的数位。 int zero = 0; while (((x &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++; 如果我们要向上方移动，横着看，我们就需要向前 444 个数位。例如，我们要把 000 上移： 123456789abcdef0 ^ 123456789ab0defc ^ 其本质是： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ 1 2 3 4 5 6 7 8 9 10 11 _ 13 14 15 12 于是，你就可以写出代码，获取 000 上方的数字是多少： int top = zero + 4; int dig = (x &gt;&gt; (top &lt;&lt; 2)) &amp; 15; 奇怪，第一行为什么是 zero + 4 而不是 zero - 4 呢？不知道你们有没有发现，我们的数位是颠倒的。所以正确的移动其实是第 000 位到第 444 位。： 123456789abcdef0 ^ 0 123456789ab0defc ^ 4 不过到目前为止，我们只是获取到了 dig←12dig \\leftarrow 12dig←12。我们还需要把这个数字移动到 000 原来所在的位置。 x |= (unsigned long long)dig &lt;&lt; (zero &lt;&lt; 2); 这行代码使用「或」运算，因为 000 的二进制全部为 000，所以或运算本质上就是拷贝。 于此同时，我们还需要把原来上方的格子清零。我们需要「与」运算。运算时，我们需要保证上方的格子对应「0」从而删除，而其他的位置不变。于是自然又会想到将 (15)10=(1111)2\\left(15\\right)_{10} = \\left(1111\\right)_2(15)10​=(1111)2​ 移动到那一位，同时取反，让其他位变为 111——不干扰。 于是写出： x &amp;= ~((unsigned long long)15 &lt;&lt; (top &lt;&lt; 2)); 整理一下上方所有的位运算，压到一行里： x = (x | ((x &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2)) &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2)); 搞定！其他方向同理，于是我们就可以写出搜索时的代码。 判断无解 为了方便我的时间测量，防止没必要的浪费，我有必要写出来判断无解的代码。 让我们观察一下有解的几种情况。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 _ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 _ 15 1 2 3 4 5 6 7 8 9 10 11 _ 13 14 15 12 为了方便处理，我们可以把二维转为一维，和之前一样，从上到下，从左到右。 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0][1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15][1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0][1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15][1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12] 从数列中删去 000，得到了： [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\\right] \\\\ \\left[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,12,13,14,15][1,2,3,4,5,6,7,8,9,10,11,13,14,15,12] 你会发现，第一行和第二行没有变化。第三行相对两者来说，121212 移动到了 [13,14,15]\\left[13, 14, 15\\right][13,14,15] 的后方，创造了 333 个逆序对。 让我们再把空格往上移动一下。 1 2 3 4 5 6 7 _ 9 10 11 8 13 14 15 12 [1,2,3,4,5,6,7,9,10,11,8,13,14,15,12]\\left[1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 8, 13, 14, 15, 12\\right] [1,2,3,4,5,6,7,9,10,11,8,13,14,15,12] 注意到 888 向后移动了 333 格，创造了 333 个逆序对，此时共有 666 个逆序对。 仔细观察，会发现 000 的坐标与逆序对的奇偶性有关系。每当 000 向上移动奇数行（所在坐标也为奇数行），逆序对的数量为奇数。反之，在偶数行时，逆序对的数量为偶数。 对于左右移动，不影响序列，所以我们不必考虑。 和位运算周旋半个小时就可以写出下面的代码： bool hasSolution(puzzle p) { int cnt = 0, zeroX = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) { zeroX = i &gt;&gt; 2; continue; } for (int j = 0; j &lt; i; j++) { int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15; if (y == 0) continue; if (y &lt; x) cnt++; } } return ((cnt + zeroX) &amp; 1) == 0; } 最后写完整代码时发现之前的 cost 没有任何作用，就删掉了。另外，为了加快速度，我改成了 unordered_map 和 unordered_set。 #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;unordered_set&gt; #include &lt;unordered_map&gt; using namespace std; #define puzzle unsigned long long inline bool isValid(puzzle p) { unsigned exist = 0; for (int i = 0; i &lt; 16; i++) { int x = p &amp; 15; if (x &lt; 0 || x &gt; 15) return false; if (exist &amp; (1llu &lt;&lt; x)) return false; exist |= (1llu &lt;&lt; x); p &gt;&gt;= 4; } return true; } unsigned getScore(puzzle p) { unsigned score = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) continue; score += abs((i &gt;&gt; 2) - ((x - 1) &gt;&gt; 2)) + abs((i &amp; 3) - ((x - 1) &amp; 3)); } return score; } bool hasSolution(puzzle p) { int cnt = 0, zeroX = 0; for (int i = 0; i &lt; 16; i++) { int x = (p &gt;&gt; ((15 - i) &lt;&lt; 2)) &amp; 15; if (x == 0) { zeroX = i &gt;&gt; 2; continue; } for (int j = 0; j &lt; i; j++) { int y = (p &gt;&gt; ((15 - j) &lt;&lt; 2)) &amp; 15; if (y == 0) continue; if (y &lt; x) cnt++; } } return ((cnt + zeroX) &amp; 1) == 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); puzzle p = 0; for (int i = 0; i &lt; 16; i++) { int x; cin &gt;&gt; x; p = (p &lt;&lt; 4) + x; } int time = clock(); if (!isValid(p)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } if (!hasSolution(p)) { cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } priority_queue&lt;pair&lt;unsigned, puzzle&gt;, vector&lt;pair&lt;unsigned, puzzle&gt;&gt;, greater&lt;pair&lt;unsigned, puzzle&gt;&gt;&gt; pq; unordered_map&lt;puzzle, puzzle&gt; parent; unordered_map&lt;puzzle, char&gt; direction; unordered_map&lt;puzzle, unsigned&gt; depth; pq.push(make_pair(0, p)); depth[p] = 1; while (!pq.empty()) { puzzle curr = pq.top().second; pq.pop(); if (curr == 0x123456789abcdef0llu) { stack&lt;char&gt; path; while (curr != p) { path.push(direction[curr]); curr = parent[curr]; } cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; path.size() &lt;&lt; &quot; steps):&quot; &lt;&lt; endl; int cnt = 0; while (!path.empty()) { cout &lt;&lt; path.top() &lt;&lt; (((++cnt) % 5 == 0) ? &quot; &quot; : &quot;&quot;); path.pop(); } cout &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } unsigned currDepth = depth[curr]; int zero = 0; while (((curr &gt;&gt; (zero &lt;&lt; 2)) &amp; 15) != 0) zero++; if (zero &lt; 12) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 4) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero + 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'D'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if (zero &gt; 3) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 4) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero - 4) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'U'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if ((zero &amp; 3) != 3) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero + 1) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero + 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'R'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } if ((zero &amp; 3) != 0) { puzzle next = (curr &amp; ~((unsigned long long)15 &lt;&lt; ((zero - 1) &lt;&lt; 2))) | ((curr &gt;&gt; ((zero - 1) &lt;&lt; 2)) &amp; 15) &lt;&lt; (zero &lt;&lt; 2); if (depth.find(next) == depth.end() || depth[next] &gt; currDepth + 1) { depth[next] = currDepth + 1; parent[next] = curr; direction[next] = 'L'; pq.push(make_pair(getScore(next) + currDepth + 1, next)); } } } cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl &lt;&lt; &quot;Time: &quot; &lt;&lt; (clock() - time) * 1000.0 / CLOCKS_PER_SEC &lt;&lt; &quot;ms&quot; &lt;&lt; endl; return 0; } 我又提供了一份提高组的阅读程序代码。考察重点：位运算；难度★★★★★。 它运行起来，更快了。看到它运行起来，我更快乐。你无法想象这东西我调试了多久。 位运算确实提升了不少。 更快的方法 至此，搜索我们基本到头了。但是在一些复杂的题目上，仍然要花几分钟才能算出。 我们是想要什么？是要最优解吗？那么搜索当然可以。 但我的目标不是这个。我的目标是在做任何题目的时候都快速解决，但是步数没有太大要求。 wikiHow，该你出场了\b：https://www.wikihow.com/Solve-a-15-Puzzle 请读者先自行阅读上方文章。 一切都很轻松，除了几个问题，需要我们细化。 人类很容易移动，那么计算机怎么办？如何从机械的角度看待「移动」的过程？ 文中 3.2 说：「Place 9 on the right side of 13. Move 13 temporarily if you have to.」[2]什么时候叫做「if you have to.」？我又该如何移动？ 最后一步「If they don't go to their original places, do method 3 again by mixing only the last two rows.」[3]有何意义？ 然后，我们来进行解决。 问题 1 将一个数码往上移，本质上是将空格移动到其上方，然后再将空格移动到原数码的位置。这是因为每次移动空格本质上是与相邻的数码交换位置。 问题 2 通过玩实体的 15 数码，我发现有 2 种情况需要移动「13」。分别是（? 代表任意数字，包括空格；_ 代表空格，此时 ? 不包括空格）： 1 2 3 4 5 6 7 8 13 ? ? ? 9 ? ? ? 1 2 3 4 5 6 7 8 13 ? ? ? _ 9 ? ? 这两种情况很容易互相转换。可以这样： 将右侧 6 个 ? 中的空格移动到 999 的右侧，得到：1 2 3 4 5 6 7 8 13 ? ? ? 9 _ ? ? 移动「9」。 此时，因为每当尝试将「9」改变位置时必将堵死，所以需要「13」移动。移动的方法，我总结出来以下的结果： 允许改动「13」的位置，将「9」移动到第三行、第三列（即原来「11」所在的位置）。 在将「9」保持不动的情况下，利用左下角 2×22 \\times 22×2 的空间将「13」归回原位。 移动「9」到第三行，第二列，完成此步骤。 因为第三行、第三列并不在左下角 2×22 \\times 22×2 的空间内，所以现在移动「13」的时候必将不会干扰「9」。 问题 3 一句话：实践表明，没必要。 代码实现 首先，我对于每一个格子都给予编号。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 接下来，我对于当前重要的格子和已经解决的格子，赋予 blocked 属性。 在 vector&lt;int&gt; findPath(int from, int to); 中，程序会通过宽度优先搜索，给出一条 from→tofrom \\rightarrow tofrom→to 的路径，不经过 blocked 指定的格子。 在 vector&lt;int&gt; move(Puzzle puzzle, int from, int to); 中，程序会多次调用 findpath()，将在 from 位置上的数码移动到 to，即包括了空格子的计算。 在 bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to); 中，程序会记录答案，并返回是否成功。 更多的内容，请参照注释。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; typedef vector&lt;vector&lt;int&gt;&gt; Puzzle; #define cell2num(x, y) ((x)*4 + (y)) // check if the puzzle is valid bool isValid(Puzzle puzzle) { vector&lt;bool&gt; exist(16, false); for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] &lt; 0 || puzzle[i / 4][i % 4] &gt; 15) return false; if (exist[puzzle[i / 4][i % 4]]) return false; exist[puzzle[i / 4][i % 4]] = true; } return true; } // get if the puzzle has solution bool hasSolution(Puzzle puzzle) { int inversions = 0; int zeroRow = 0; for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] == 0) { zeroRow = i / 4; continue; } for (int j = 0; j &lt; i; j++) { if (puzzle[j / 4][j % 4] == 0) continue; if (puzzle[j / 4][j % 4] &gt; puzzle[i / 4][i % 4]) inversions++; } } return (inversions + zeroRow) % 2 == 1; // the index starts from 0, so the result of inversions should be ~~even~~ -&gt; odd } vector&lt;vector&lt;bool&gt;&gt; blocked(4, vector&lt;bool&gt;(4, false)); // the cells that have been already solved will be blocked const string arrows[4] = { &quot;↑&quot;, &quot;↓&quot;, &quot;←&quot;, &quot;→&quot; }; const int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }; // opposite to the arrows, because when we play the game, we don't move the empty cell, but move the numbers // but in the code, we move the empty cell, so the direction is opposite to the arrows // get the position of the number int getPos(Puzzle puzzle, int num) { for (int i = 0; i &lt; 16; i++) { if (puzzle[i / 4][i % 4] == num) return i; } return -1; } // find the path from the start to the end, do not need the puzzle itself, but 'blocked' is needed vector&lt;int&gt; findPath(int from, int to) { queue&lt;int&gt; q; vector&lt;int&gt; parent(16, -1); // the parent of the cell, -1 means not visited, -2 means the start cell q.push(from); parent[from] = -2; // using BFS to find the path, can be replaced by A* // but it's not necessary since the puzzle is small while (!q.empty()) { int cur = q.front(); q.pop(); if (cur == to) break; int x = cur / 4, y = cur % 4; for (int i = 0; i &lt; 4; i++) { int nx = x + dir[i][0], ny = y + dir[i][1]; if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4) continue; if (blocked[nx][ny]) continue; int next = cell2num(nx, ny); if (parent[next] != -1) continue; parent[next] = cur; q.push(next); } } if (parent[to] == -1) return vector&lt;int&gt;(); // get the path stack&lt;int&gt; transit; while (to != -2) { transit.push(to); to = parent[to]; } // get the direction of the path vector&lt;int&gt; path; while (transit.size() &gt; 1) { int from = transit.top(); transit.pop(); int to = transit.top(); int xFrom = from / 4, yFrom = from % 4; int xTo = to / 4, yTo = to % 4; for (int i = 0; i &lt; 4; i++) { if (xFrom + dir[i][0] == xTo &amp;&amp; yFrom + dir[i][1] == yTo) { path.push_back(i); break; } } } return path; } vector&lt;int&gt; move(Puzzle puzzle, int from, int to) { // find a whole path from the start to the end vector&lt;int&gt; path = findPath(from, to); if (path.empty()) return vector&lt;int&gt;(); vector&lt;int&gt; moves; // the moves that need to be done, including the empty cell int currX = from / 4, currY = from % 4; for (int i = 0; i &lt; path.size(); i++) { int nextX = currX + dir[path[i]][0], nextY = currY + dir[path[i]][1]; int zeroPos = getPos(puzzle, 0); int zeroX = zeroPos / 4, zeroY = zeroPos % 4; if (zeroPos != cell2num(nextX, nextY)) { // the empty cell is not next to the number, so the move is not valid // move the empty cell to the position next to the number // block the current cell blocked[currX][currY] = true; // find the path from the empty cell to the position next to the number vector&lt;int&gt; path2 = findPath(zeroPos, cell2num(nextX, nextY)); if (path2.empty()) return vector&lt;int&gt;(); // move the empty cell for (int j = 0; j &lt; path2.size(); j++) { int nextZeroX = zeroX + dir[path2[j]][0], nextZeroY = zeroY + dir[path2[j]][1]; moves.push_back(path2[j]); swap(puzzle[zeroX][zeroY], puzzle[nextZeroX][nextZeroY]); zeroX = nextZeroX, zeroY = nextZeroY; } // unblock the current cell blocked[currX][currY] = false; } // moves.push_back(path[i]); this is the move of the number, not the empty cell // move push_back opposite (0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2) moves.push_back(path[i] ^ 1); swap(puzzle[currX][currY], puzzle[nextX][nextY]); currX = nextX, currY = nextY; } return moves; } bool calc(Puzzle&amp; puzzle, vector&lt;int&gt;&amp; ans, int from, int to) { // do not need to move if (from == to) return true; vector&lt;int&gt; moves = move(puzzle, from, to); if (moves.empty()) return false; for (int i = 0; i &lt; moves.size(); i++) { ans.push_back(moves[i]); int zeroPos = getPos(puzzle, 0); int zeroX = zeroPos / 4, zeroY = zeroPos % 4; swap(puzzle[zeroX][zeroY], puzzle[zeroX + dir[moves[i]][0]][zeroY + dir[moves[i]][1]]); } return true; } int main() { Puzzle puzzle(4, vector&lt;int&gt;(4)); for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) cin &gt;&gt; puzzle[i][j]; } if (!isValid(puzzle)) { cout &lt;&lt; &quot;Invalid puzzle&quot; &lt;&lt; endl; return 0; } if (!hasSolution(puzzle)) { cout &lt;&lt; &quot;No solution&quot; &lt;&lt; endl; return 0; } vector&lt;int&gt; ans; bool flag = true; // step 1: move [1] to pos 0 flag &amp;= calc(puzzle, ans, getPos(puzzle, 1), 0); blocked[0][0] = true; // step 2: move [2] to pos 1 flag &amp;= calc(puzzle, ans, getPos(puzzle, 2), 1); blocked[0][1] = true; // step 3: move [4] to pos 2 flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2); // step 4: if [3] is in pos 3 or (7 &amp;&amp; 3 is empty), we have to move it away // -&gt; move [3] to pos 10 if (getPos(puzzle, 3) == 3 || (getPos(puzzle, 3) == 7 &amp;&amp; getPos(puzzle, 0) == 3)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 10); blocked[2][2] = true; // move [4] back to pos 2, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 2); blocked[2][2] = false; } blocked[0][2] = true; // step 5: move [3] to pos 6 flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 6); blocked[1][2] = true; // step 6: move [4] to pos 3 blocked[0][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 4), 3); blocked[0][3] = true; // step 7: move [3] to pos 2 blocked[1][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 3), 2); blocked[0][2] = true; // now we have [1] [2] [3] [4] in the right place, and they are blocked // step 8: move [5] to pos 4 flag &amp;= calc(puzzle, ans, getPos(puzzle, 5), 4); blocked[1][0] = true; // step 9: move [6] to pos 5 flag &amp;= calc(puzzle, ans, getPos(puzzle, 6), 5); blocked[1][1] = true; // step 10: move [8] to pos 6 flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6); // step 11: if [7] is in pos 7 or (11 &amp;&amp; 7 is empty), we have to move it away // -&gt; move [7] to pos 14 if (getPos(puzzle, 7) == 7 || (getPos(puzzle, 7) == 11 &amp;&amp; getPos(puzzle, 0) == 7)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 14); blocked[3][2] = true; // move [8] back to pos 6, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 6); blocked[3][2] = false; } blocked[1][2] = true; // step 12: move [7] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 10); blocked[2][2] = true; // step 13: move [8] to pos 7 blocked[1][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 8), 7); blocked[1][3] = true; // step 14: move [7] to pos 6 blocked[2][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 7), 6); blocked[1][2] = true; // now we have [5] [6] [7] [8] in the right place, and they are blocked // step 15: move [13] to pos 8 flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8); // step 16: if 9 is in pos 12 or (13 &amp;&amp; 12 is empty), we have to move it away // -&gt; move [9] to pos 10 if (getPos(puzzle, 9) == 12 || (getPos(puzzle, 9) == 13 &amp;&amp; getPos(puzzle, 0) == 12)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 10); blocked[2][2] = true; // move [13] back to pos 8, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 8); blocked[2][2] = false; } blocked[2][0] = true; // step 17: move [9] to pos 9 flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 9); blocked[2][1] = true; // step 18: move [13] to pos 12 blocked[2][0] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 13), 12); blocked[3][0] = true; // step 19: move [9] to pos 8 blocked[2][1] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 9), 8); blocked[2][0] = true; // now we have [9] [13] in the right place, and they are blocked // step 20: move [14] to pos 9 flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9); // step 21: if [10] is in pos 13 or (14 &amp;&amp; 13 is empty), we have to move it away // -&gt; move [10] to pos 11 if (getPos(puzzle, 10) == 13 || (getPos(puzzle, 10) == 14 &amp;&amp; getPos(puzzle, 0) == 13)) { flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 11); blocked[2][3] = true; // move [14] back to pos 9, since we moved it away in the calc() above flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 9); blocked[2][3] = false; } blocked[2][1] = true; // step 22: move [10] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 10); blocked[2][2] = true; // step 23: move [14] to pos 13 blocked[2][1] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 14), 13); blocked[3][1] = true; // step 24: move [10] to pos 9 blocked[2][2] = false; flag &amp;= calc(puzzle, ans, getPos(puzzle, 10), 9); blocked[2][1] = true; // now we have [10] [14] in the right place, and they are blocked // step 25: move [11] to pos 10 flag &amp;= calc(puzzle, ans, getPos(puzzle, 11), 10); blocked[2][2] = true; // step 26: move [12] to pos 11 flag &amp;= calc(puzzle, ans, getPos(puzzle, 12), 11); blocked[2][3] = true; // step 27: move [15] to pos 14 flag &amp;= calc(puzzle, ans, getPos(puzzle, 15), 14); blocked[3][2] = true; // now we have [11] [12] [15] in the right place, and they are blocked if (!flag) { cout &lt;&lt; &quot;Something went wrong&quot; &lt;&lt; endl; return 0; } // make the answer simpler, removing unnecessary moves for (int i = 0; i &lt; ans.size(); i++) { if ((ans[i] ^ ans[i + 1]) == 1) { ans.erase(ans.begin() + i); ans.erase(ans.begin() + i); i -= 2; // go back 2 steps, to make sure we didn't create another unnecessary move } } // print the answer cout &lt;&lt; &quot;Solution (&quot; &lt;&lt; ans.size() &lt;&lt; &quot; moves):&quot; &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; arrows[ans[i]]; if (i % 5 == 4) cout &lt;&lt; ' '; } cout &lt;&lt; endl; return 0; } 你可能会问：为什么 move() 和 calc() 不能合并在一块儿？ 优质答案：我不知道可以，但是我不想改了。 你又会问：为什么你连位运算都改了，却不愿意改这个？ 优质答案：去写暑假作业了。[4] 由 M1 驱动的 MacBook Air 运算。在其他的电脑上，运行时间可能有所不同。 ↩︎ https://www.wikihow.com/Solve-a-15-Puzzle#step-id-213 ↩︎ https://www.wikihow.com/Solve-a-15-Puzzle#step-id-222 ↩︎ 如下图，共 556 份。 ↩︎ ","link":"https://oimaster.top/post/-jrYcZ0cc/"},{"title":"强连通分量与缩点","content":"最近复习了关于强连通分量和缩点的知识，有了很多新的感悟，写一篇学习笔记出来供自己查阅。 强连通分量 定义 『强连通』指的是在一个有向图 GGG 中，任意两点连通，也就是至少存在一条路径。 『强连通分量』[1]指的是尽可能大的『强连通』子图。 例如，在这幅图中，子图 {1,2,5,6}\\{1, 2, 5, 6\\}{1,2,5,6} 是一个强连通分量，这是因为它们之间两两可达。子图 {3}\\{3\\}{3} 与子图 {4}\\{4\\}{4} 也是两个大小为 111 的强连通分量。 解法 求解强连通分量问题，有多种算法。本文介绍 Tarjan 算法。首先，需要了解『DFS 生成树』。这是一个示例： 其中，有若干种边。 『树边』：每次搜索到一个没有访问过的节点时会形成一条树边； 『返祖边』[2]：指向自己祖先节点的边； 『横叉边』：在搜索中遇到了一个已经访问过的节点，但是这个节点并不是自己的祖先； 『前向边』：在搜索时遇到了自己子树中的节点形成，且这个节点已经被访问过，即不和自己相邻。 对于每个节点 iii，设 dfnidfn_idfni​ 为这个节点的 dfs 序。举个例子，在上图中，dfnidfn_idfni​ 被写在了每个节点内部。同时，设 lowilow_ilowi​ 表示在以 iii 为根的子树中的任意一个点出发，经过最多一条非子树内的边后，可以到达的节点中最小的 dfndfndfn。例如，在上图中，每个节点的 lowlowlow 值以红色标到节点旁边。 在搜索之前，先了解一个基本的性质。如果 uuu 是一个强连通分量内第一个被搜索到的节点，那么这个强连通分量内剩下的所有节点都在 uuu 的子树中，uuu 也被称为这个强连通分量的**『根』**。可以简单地证明一下。 如果在这个强连通分量内还有一个不同于 uuu 的节点 vvv，且 vvv 不在 uuu 的子树中，那么因为强连通分量的定义，必须会有一条路径能从 uuu 到 vvv。此时，这条路径上不可能只包含树边，一定还有横叉边或者返祖边。但是横叉边和返祖边的前提是 vvv 一定是已经被搜索到了，不符合『uuu 是一个强连通分量内第一个被搜索到的节点』，所以这个性质成立。 在搜索的时候，会遇到几种情况。假设现在搜索到节点 uuu，正看到 uuu 的相邻节点 vvv。 vvv 没有被访问过。此时递归搜索 vvv，并直接继承 lowvlow_vlowv​ 到 lowulow_ulowu​。这是因为如果节点 vvv 能访问到 lowvlow_vlowv​，那么 uuu 只需要多走一条有向边也可以访问到 lowvlow_vlowv​，所以可以直接使 lowulow_ulowu​ 取小者； vvv 已经被访问过。此时又需要分情况讨论： vvv 属于一个已知的强连通分量内。此时不需要做任何事情。这是因为如果 uuu 之前属于 vvv 的强连通分量内，就一定会以 vvv 的子树节点出现。这明显是不符合目前的情况的，所以直接忽略。 vvv 不属于一个已知的强连通分量内。根据 lowlowlow 值的定义，可以尝试使用 dfnvdfn_vdfnv​ 更新 lowulow_ulowu​。 为了判断上面的 vvv 是否在一个已知的强连通分量内，有一种方法是维护一个栈。将一个强连通分量的节点放在一起，当发现后统一弹出并记录。 如何发现一个强连通分量？在一个强连通分量中，必定有且仅有 111 个 uuu 使得 dfnu=lowudfn_u = low_udfnu​=lowu​。这个节点就是该强连通分量的根。因为在一个强连通分量中，根的 dfndfndfn 一定最小，所以不会被任何一个强连通分量内的其他节点所影响。 示例 为了方便理解，不如举个例子。这是原始的图。 从节点 111 启动搜索。绿色代表正在递归中的边。灰色代表已经搜索过的边。节点内部的数字代表着其编号（为了方便理解，这个编号也等于其 dfndfndfn），节点旁边的绿色数字为该节点的 lowlowlow。右侧为栈内空间。 按照顺序，接下来应该搜索 222。 按照顺序，接下来应该搜索 333。 按照顺序，接下来应该搜索 444。 节点 444 没有指出去的有向边，无法继续搜索。此时发现 low4=dfn4low_4 = dfn_4low4​=dfn4​，于是判定 {4}\\{4\\}{4} 为强连通分量，并弹栈。 回溯到节点 333。 此时注意到 333 已经没有更多的有向边指出去，停止拓展。发现 low3=dfn3low_3 = dfn_3low3​=dfn3​，判断 {3}\\{3\\}{3} 为强连通分量，并弹栈。 回溯到节点 222。 发现一条有向边 (2,5)(2, 5)(2,5)，于是开始搜索节点 555。 接下来，搜索节点 111。发现节点 111 被访问过且在栈中。根据规则，更新 low5←dfn1low_5 \\leftarrow dfn_1low5​←dfn1​。 同样地，搜索节点 444。节点 444 曾被访问过但是不在栈中。根据上面的规则，得知 444 一定处在一个已知的强连通分量中，这也是满足示例的。所以不动。 用 low3low_3low3​ 更新 low2low_2low2​，但是因为 low3&gt;low2low_3 &gt; low_2low3​&gt;low2​ 所以不用做任何事情。接下来，搜索节点 666。 发现连接节点 111 的有向边。节点 111 曾经被访问过且在栈中。更新 low6low_6low6​。 没有更多的边了。发现 low6=dfn6low_6 \\not = dfn_6low6​​=dfn6​，不是一个强连通分量。 回溯。 回到 555 节点。注意此时栈中不要弹出 666。用 low6low_6low6​ 更新 low5low_5low5​。因为一样大所以不用做任何事情。 没有更多的边了。发现 low5=dfn5low_5 \\not = dfn_5low5​​=dfn5​，不是一个强连通分量。 回溯。 节点 222 没有更多的边了。更新 low2←low5low_2 \\leftarrow low_5low2​←low5​。 此时 222 已经没有更多的边。发现 low2=dfn2low_2 \\not = dfn_2low2​​=dfn2​，不是一个强连通分量。 回溯。 用 low2low_2low2​ 更新 low1low_1low1​，但是因为一样大所以什么都不用做。 此时发现 low1low_1low1​ 没有更多边了，于是开始判断。low1=dfn1low_1 = dfn_1low1​=dfn1​，也就是说，111 是某个强连通分量的根。 开始弹栈，直到栈顶为 111，并记录下来所弹出来的节点，得到一个新的强连通分量。 注意要连带 111 一起弹出。现在已经探索到了所有的节点。回到主函数。 至此，我们已经找到了所有的强连通分量 {1,2,5,6}\\{1, 2, 5, 6\\}{1,2,5,6} 、 {3}\\{3\\}{3} 与 {4}\\{4\\}{4}。 代码 int n, m; vector&lt;int&gt; e[10010]; int dfn[10010]; int low[10010]; int cnt; int sid[10010]; int siz[10010]; int scnt; bool inStack[10010]; bool vis[10010]; stack&lt;int&gt; st; void tarjan(int u) { vis[u] = true; ++cnt; dfn[u] = low[u] = cnt; st.push(u); inStack[u] = true; for (auto i : e[u]) if (!vis[i]) { tarjan(i); low[u] = min(low[u], low[i]); } else if (inStack[i]) low[u] = min(low[u], dfn[i]); if (dfn[u] == low[u]) { ++scnt; while (st.top() != u) { sid[st.top()] = scnt; ++siz[scnt]; inStack[st.top()] = false; st.pop(); } st.pop(); sid[u] = scnt; ++siz[scnt]; inStack[u] = false; } } 缩点 没什么技巧，就是把强连通分量的环当作一个新的点，重新构造一遍图即可。注意不要出现自环。 构造出来的一定是一个 DAG[3]。 代码 for (int i = 1; i &lt;= n; ++i) e[i].clear(); for (int i = 1; i &lt;= m; ++i) { int u = sid[ex[i]]; int v = sid[ey[i]]; if (u != v) e[u].push_back(v); } 习题 缩点模板 题目描述 链接：https://www.luogu.com.cn/problem/P3387 解法 完成 Tarjan、缩点后，跑一遍拓扑排序就可以解决。 代码实现 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; int a[10010]; vector&lt;int&gt; e[10010]; int ex[100010]; int ey[100010]; int dfn[10010]; int low[10010]; bool inStack[10010]; bool vis[10010]; stack&lt;int&gt; st; int cnt; vector&lt;int&gt; newe[10010]; int sid[10010]; int siz[10010]; int scnt; queue&lt;int&gt; topo; int dis[10010]; int deg[10010]; int ans; void tarjan(int u) { vis[u] = true; ++cnt; dfn[u] = cnt; low[u] = cnt; st.push(u); inStack[u] = true; for (auto i : e[u]) if (vis[i] == false) { tarjan(i); low[u] = min(low[u], low[i]); } else if (inStack[i] == true) low[u] = min(low[u], dfn[i]); if (dfn[u] == low[u]) { ++scnt; while (st.top() != u) { sid[st.top()] = scnt; siz[scnt] += a[st.top()]; inStack[st.top()] = false; st.pop(); } st.pop(); sid[u] = scnt; siz[scnt] += a[u]; inStack[u] = false; } } void toposort() { for (int i = 1; i &lt;= scnt; ++i) if (deg[i] == 0) { dis[i] = siz[i]; topo.push(i); } while (!topo.empty()) { int now = topo.front(); topo.pop(); for (auto i : newe[now]) { dis[i] = max(dis[i], dis[now] + siz[i]); --deg[i]; if (deg[i] == 0) topo.push(i); } } } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; ex[i] &gt;&gt; ey[i]; e[ex[i]].push_back(ey[i]); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i); for (int i = 1; i &lt;= m; ++i) { int u = sid[ex[i]]; int v = sid[ey[i]]; if (u != v) { newe[u].push_back(v); ++deg[v]; } } toposort(); for (int i = 1; i &lt;= scnt; ++i) ans = max(ans, dis[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0; } 总结 这是一个比较有用的算法。不少图论问题可以通过 Tarjan 转换成 DAG，然后进行拓扑排序等操作，可以在图上进行动态规划。 在 之前的一篇文章 中，并未详细解释这棵『DFS 生成树』，只是称为『一棵树』[4]了之。读者不妨回头看看，可能会有更深的收获。 另外，请让我说一句，『这些图片真的累死我了』！ Strongly Connected Components，缩写为 SCC。 ↩︎ 也可以称为『后向边』、『回边』，英文为『back edge』。 ↩︎ Directed Acyclic Graph，有向无环图。 ↩︎ 『可以将一张图看作一棵树』。 ↩︎ ","link":"https://oimaster.top/post/29iMUCdw4/"},{"title":"割点与桥","content":"最近学习了关于割点和桥的知识，写一篇学习笔记出来供自己复习。 割点 定义 在一个无向图中，如果删除一个点以及与它相邻的边后，图中的连通块数量增加，那么就称这个点为**『割点』**。 这里有一张图，可以更清楚地理解一下。 在这张图中，如果删除了节点 555，那么图就会变成这样： 图中的连通块个数从 111 变成了 222，可见节点 555 就是这张图的『割点』。 解法 求解图中的割点，可以使用 Tarjan 算法。 首先，令 dfnidfn_idfni​ 为节点 iii 的 dfs 序。通过 dfs，可以将一张图看作一棵树。刚才的图可以被标记成这样。其中，再节点 iii 旁边的红色数字代表 dfnidfn_idfni​，被红色标记的边为树上的边。 接下来，对于每一个点 iii，设 lowilow_ilowi​ 表示从点 iii 的子树中的任意一个点出发，经过最多一条非子树内的边后，可以到达的节点中最小的 dfndfndfn。 为了方便查看，我整理了一下这张图，使它看上去像棵树。 举个例子，在上图中，如果把节点 111 看作根，lowlowlow 数组的值就为 [1,1,1,1,1,3][1, 1, 1, 1, 1, 3][1,1,1,1,1,3]。 为了方便理解，我解释一下为什么 low6low_6low6​ 为 333。在 666 的子树中，只有 666 一个节点。也就是说，边 (5,6)(5, 6)(5,6) 并不属于 666 子树内的一条边。所以，能去到的 dfndfndfn 最小的节点编号为 555，经过 (5,6)(5, 6)(5,6) 一条非子树边，low6←dfn5low_6 \\leftarrow dfn_5low6​←dfn5​。 同样地，对于节点 222，它的子树中有节点 2,3,4,5,62, 3, 4, 5, 62,3,4,5,6。可以得到的最小的 dfndfndfn 便是通过子树边 (2,5)(2, 5)(2,5)、(5,3)(5,3)(5,3)，再经过一条非子树边 (3,1)(3, 1)(3,1) 到达节点 111。于是，low2←dfn1low_2 \\leftarrow dfn_1low2​←dfn1​。注意这里无法直接从 (2,1)(2, 1)(2,1) 到达节点 111，因为边 (2,1)(2, 1)(2,1) 并不是一条以 222 为根的子树边。 所以，如果节点 iii 的子树中存在一点 jjj，使得 lowj≥dfnilow_j \\ge dfn_ilowj​≥dfni​，那么就可以得到 iii 一定是一个割点。原因是，根据上面的定义，如果要从 jjj 到任何一个满足 dfnk&lt;dfnidfn_k &lt; dfn_idfnk​&lt;dfni​ 的节点 kkk，是没有办法直接从 jjj 的子树到达的，必须通过 iii。因此，如果删除 iii，jjj 和 kkk 就无法互相到达了，连通块数量增加，iii 是一个割点。 但是有一个点是特殊的，这就是整棵树的根。这个节点无法通过上面的方法解决，因为它不是任何节点的孩子。不过也不困难。如果根节点 111 有 222 个及以上的子树，那么如果切断 111，这些子树将无法连接。注意，子树之间是不可能有边连接的，这是因为在获得子树的 dfs 中，能与一棵子树相连的节点全都会被归到一个子树中。 代码 题目链接：https://www.luogu.com.cn/problem/P3388 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int n, m; vector&lt;int&gt; e[20010]; vector&lt;int&gt; p; int dfn[20010]; int low[20010]; int cnt; void tarjan(int u, bool root) { int tot = 0; // dfs 序 ++cnt; dfn[u] = cnt; low[u] = cnt; for (auto i : e[u]) if (dfn[i]) low[u] = min(low[u], dfn[i]); // i 不是 u 的子树。(i, u) 是一条非子树边。 else { tarjan(i, false); low[u] = min(low[u], low[i]); // i 是 u 的子树，所以 u 可以直接收取 i 的答案。 if (low[i] &gt;= dfn[u]) ++tot; } if ((root == true &amp;&amp; tot &gt; 1) || (root == false &amp;&amp; tot &gt; 0)) p.push_back(u); } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i, true); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; dfn[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; low[i] &lt;&lt; ' '; cout &lt;&lt; endl; sort(p.begin(), p.end()); cout &lt;&lt; p.size() &lt;&lt; endl; for (auto i : p) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl; } 桥 定义 在一个无向图中，如果删除一条边后，图中的连通块数量增加，那么就称这条边为**『桥』**[1]。 这里还是那张图，可以更清楚地理解一下。 在这张图后，如果删除了边 (5,6)(5, 6)(5,6)，那么图会变成这样： 图中的连通块个数从 111 变成了 222，可见边 (5,6)(5, 6)(5,6) 就是这张图的『桥』。 解法 与刚才的解法类似。 将 lowlowlow 的定义稍微修改一下，修改的地方加粗显示。对于每一个点 iii，设 lowilow_ilowi​ 表示从点 iii 的子树中的任意一个点出发，经过最多一条非子树内的边且这条边不连接自己的父亲，可以到达的节点中最小的 dfndfndfn。 对于修改后的 lowlowlow，可以得到，如果节点 uuu 是节点 vvv 的父亲，且 dfnu&lt;lowvdfn_u &lt; low_vdfnu​&lt;lowv​，那么边 (u,v)(u, v)(u,v) 是桥。 理由：假设 (u,v)(u, v)(u,v) 不是桥，那么当删除边 (u,v)(u, v)(u,v) 后，vvv 一定可以通过连接自己子树的一些边跳到 uuu 或者 dfndfndfn 小于 uuu 的点。要想这样，就会有 dfnu≥lowvdfn_u \\ge low_vdfnu​≥lowv​，与上面的式子矛盾了。所以 (u,v)(u, v)(u,v) 一定是桥。 那么为什么需要修改定义？如果不修改定义，那么 vvv 一定可以通过连接自己父亲的边直接跳到 uuu，就不可能找到任何的桥。 代码 提交链接暂时没有。 如果有重边的话，下面的代码就不能通过了。这是因为如果有重边的话，代码第 171717 行就会忽略掉重边。解决这个问题可以通过链式前向星等存储无向图，使得正向边与反向边存在一起，拿到边 ididid 后通过 id⊕1id \\oplus 1id⊕1 等操作判断是否属于一条无向边，其中 ⊕\\oplus⊕ 表示异或。 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int n, m; vector&lt;int&gt; e[20010]; vector&lt;pair&lt;int, int&gt;&gt; p; int dfn[20010]; int low[20010]; int cnt; void tarjan(int u, int fa) { ++cnt; dfn[u] = cnt; low[u] = cnt; for (auto i : e[u]) if (dfn[i]) { if (i == fa) // 更改定义，忽略掉与父亲连接的边。前提是没有重边 continue; low[u] = min(low[u], dfn[i]); } else { tarjan(i, u); low[u] = min(low[u], low[i]); if (low[i] &gt; dfn[u]) // 细微的更改 p.emplace_back(u, i); } } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); } for (int i = 1; i &lt;= n; ++i) if (dfn[i] == 0) tarjan(i, 0); sort(p.begin(), p.end()); cout &lt;&lt; p.size() &lt;&lt; endl; for (auto i : p) cout &lt;&lt; i.first &lt;&lt; '-' &lt;&lt; i.second &lt;&lt; ' '; cout &lt;&lt; endl; } 桥也叫做割边。 ↩︎ ","link":"https://oimaster.top/post/Zfjel35ew/"}]}